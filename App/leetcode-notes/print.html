<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Leetcode Notes</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Leetcode Problems and Solutions</li><li class="chapter-item expanded "><div>Easy</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="easy-problems/1.html">1. Two Sum</a></li><li class="chapter-item expanded "><a href="easy-problems/206.html">206. Reverse Linked Lists</a></li><li class="chapter-item expanded "><a href="easy-problems/876.html">876.	Middle of the Linked List</a></li></ol></li><li class="chapter-item expanded "><div>Medium</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="medium-problems/3.html">3. Longest Substring Without Repeating Characters</a></li><li class="chapter-item expanded "><a href="medium-problems/151.html">151. Reverse Words in a String</a></li></ol></li><li class="chapter-item expanded "><div>Hard</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hard-problems/65.html">65. Valid Number</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Leetcode Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to my book for leetcode problems. Here you can find meaningful problems from Leetcode and my explantions of solutions.</p>
<h2 id="programming-language-used-in-solutions"><a class="header" href="#programming-language-used-in-solutions">Programming Language used in solutions</a></h2>
<ul>
<li>Rust</li>
<li>Java</li>
</ul>
<h2 id="kind-reminder"><a class="header" href="#kind-reminder">Kind Reminder</a></h2>
<ul>
<li>The book is not completed yet. I am still writing explanations for problems.</li>
<li>The book will contain only few <strong>Easy</strong> problems because most of them are not meaningful.</li>
<li>The web will be <strong>updated very slowly</strong> because explaining each solved problem will be time-consuming.</li>
<li>Some of explnations and solutions may not be correct. Espectially for the complexity of an algorithm. Sometimes I do not use rigorous calculation/proof.</li>
</ul>
<h2 id="update-notes"><a class="header" href="#update-notes">Update Notes</a></h2>
<ul>
<li>Last Updated: 2023.Jul.29
<ul>
<li>Add Problem 3, 65, 151.</li>
<li>For Problem 3, Calucation of Average Time Complexity was added</li>
<li>I suggest to read <strong>Problem 151</strong>. You will have deeper understanding about programming and Computer Science (If my explnation has no error). </li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-two-sum"><a class="header" href="#1-two-sum">1. Two Sum</a></h1>
<h2 id="description-of-the-problem"><a class="header" href="#description-of-the-problem">Description of the Problem</a></h2>
<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>You can return the answer in any order.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [3,2,4], target = 6
Output: [1,2]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: nums = [3,3], target = 6
Output: [0,1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>\(2 &lt;= nums.length &lt;= 10^4\)</li>
<li>\(-10^9 &lt;= nums[i] &lt;= 10^9\)</li>
<li>\(-10^9 &lt;= target &lt;= 10^9\)</li>
<li>Only one valid answer exists.</li>
</ul>
<p>Follow-up: Can you come up with an algorithm that is less than \(O(n^2)\) time complexity?</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<p>\( \text{IF} \ num[i]+num[j]==target \ \text{THEN} \ return [i,j] \)</p>
<p>\( \Longleftrightarrow \)</p>
<p>\( \text{IF} \ num[i]==target - num[j] \ \text{THEN} \  return [i,j] \)</p>
<h3 id="code-rust"><a class="header" href="#code-rust">Code (Rust)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

impl Solution {
    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {
        let mut hashMap = HashMap::new();

        for i in 0..nums.len(){
            let complement = target - nums[i];
            if hashMap.contains_key(&amp;complement){
                return vec![
                    i as i32 , hashMap[&amp;complement] as i32
                ];
            }
            hashMap.insert(nums[i], i);
        }
        return vec![];
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="code-java"><a class="header" href="#code-java">Code (Java)</a></h3>
<pre><code class="language-java">import java.util.HashMap;

public class Solution_2 {
    public int[] twoSum(int [] nums, int target){

        // It stores (num-&gt;index)
        HashMap &lt;Integer,Integer&gt; hashmap = new HashMap();

        for(int i = 0; i &lt; nums.length; i++){
            int complement = target - nums[i];
            if ( hashmap.containsKey(complement) ){
                return new int[] { hashmap.get(complement), i};
            }
            hashmap.put(nums[i], i);
        }

        return null;
    }

}
</code></pre>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( T(n) = \mathcal{\Theta}(n) \)
<ul>
<li>Assume hashMap get/put use constant time</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(2n) \)
<ul>
<li>It store at most 2n (key and value) elements in HashMap</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="206-reverse-linked-lists"><a class="header" href="#206-reverse-linked-lists">206. Reverse Linked Lists</a></h1>
<h2 id="description-of-the-problem-1"><a class="header" href="#description-of-the-problem-1">Description of the Problem</a></h2>
<p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2]
Output: [2,1]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: head = []
Output: []
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<h2 id="solution-1"><a class="header" href="#solution-1">Solution</a></h2>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h3>
<p>The following (Rust) code can be verified by the loop invariant </p>
<p>Invariant: All nodes before the current node are properly reversed</p>
<p>Proof: </p>
<ul>
<li>Initialisation: Before the begin of iteration, No node is before the current node, the invariant is vacuously true</li>
<li>Maintenance: Suppose the invariant is true before the iteration, having perform re-ordering operations, all nodes before the current node (originally it is next node) is properly reversed</li>
<li>Termination: After all iterations, all nodes in the LinkedList are reversed properly</li>
</ul>
<h3 id="code-rust-1"><a class="header" href="#code-rust-1">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -&gt; Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }


impl Solution {
    pub fn reverse_list(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut curr = head;
        let mut prev = None;

        while let Some(mut node) = curr.take() {
            curr = node.next; // Transfer the ownership of node.next to curr, node.next becomes None
            node.next = prev; // The next node of the current node should point to previous node
            prev = Some(node); // Current nodebecomes preivous node for next iteration
        }

        return prev;
    }
}
</code></pre>
<h3 id="complexity-1"><a class="header" href="#complexity-1">Complexity</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( T(n) = \mathcal{\Theta}(n) \)
<ul>
<li>Traversal of all nodes in LinkedList</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(1) \)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="876-middle-of-the-linked-list"><a class="header" href="#876-middle-of-the-linked-list">876.	Middle of the Linked List</a></h1>
<h2 id="description-of-the-problem-2"><a class="header" href="#description-of-the-problem-2">Description of the Problem</a></h2>
<p>Given the <code>head</code> of a singly linked list, return the middle node of the linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is in the range <code>[1, 100]</code>.</li>
<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="solution-2"><a class="header" href="#solution-2">Solution</a></h2>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h3>
<p><strong>Fast and Slow Pointers</strong></p>
<p>Slow pointer move to right by 1 and fast pointer move to right by 2 if possible.</p>
<p>At the end of loop, slow pointer must point to the middle node or previous node of the middle node</p>
<p>Here we assume the linkedlist use 0-based indexing (i.e. list[0] indicate first element of the list)</p>
<p>At the termination of the loop, there are only two possible case:</p>
<ol>
<li>fast pointer point to <strong>last</strong> element of the linkedlist</li>
<li>fast pointer point to <strong>second last</strong> element of the linkedlist;</li>
</ol>
<p>Suppose the loop ran <code>k</code> times. It implies that fast pointer mvoed to right by <code>2k</code> and slow pointer moved to right by <code>k</code>.</p>
<p>In case 1, this is because the number of nodes in the linkedlist is odd number. The total number of nodes is <code>2k + 1</code>. <code>list[k]</code> is the middle node because there are <code>k</code> elements in <code>list[0..k]</code> and in <code>list[k+1..2k+1]</code> elements<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<p>In case 2, this is becuase the number of nodes in the linkedlist is even number. The total number of nodes is 2k + 2. <code>list[0..k]</code> and <code>list[k+1..2k+2]</code> contains half number of total elements.<sup class="footnote-reference"><a href="#1">1</a></sup> Thus return slow.next;</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> The sub-indexing is exclusive. For example<code> A[i..j]</code> does not include <code>A[j]</code></p>
<h3 id="code-java-1"><a class="header" href="#code-java-1">Code (Java)</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null &amp;&amp; fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }

        return fast.next == null? slow : slow.next;
    }
}
</code></pre>
<h3 id="complexity-2"><a class="header" href="#complexity-2">Complexity</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( T(n) = O(n/2) \)
<ul>
<li>There are only nearly n/2 iterations</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(1) \)
<ul>
<li>Use only constant number of variables</li>
</ul>
</li>
</ul>
<h2 id="futher-discussion"><a class="header" href="#futher-discussion">Futher Discussion</a></h2>
<h3 id="alternative-way-to-implements-linkedlist-in-rust-and-how-to-move-a-pointer-in-rust"><a class="header" href="#alternative-way-to-implements-linkedlist-in-rust-and-how-to-move-a-pointer-in-rust">Alternative way to implements LinkedList in Rust and How to move a pointer in Rust</a></h3>
<p>Althougt it is possible to implement LinkedList in Rust by <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>, I do not know why leetcode refuse to use it. I would like to provide another implementation that supports fast and slow pointers approach. The key difficulty is moving pointer.</p>
<pre><code class="language-Rust">use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug, PartialEq)]
struct LinkedNode {
    val : i32,
    next : Option&lt;Rc&lt;RefCell&lt;LinkedNode&gt;&gt;&gt;,
}

impl LinkedNode {
    fn new(val : i32, next: Option&lt;Rc&lt;RefCell&lt;LinkedNode&gt;&gt;&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;LinkedNode&gt;&gt;&gt;{
        Some(
            Rc::new(
                RefCell::new(
                    LinkedNode{
                        val, 
                        next
                    }
                )
            )
        )
    }
}

fn main() {

    let node_2 = LinkedNode::new(2, None);
    let node_1 = LinkedNode::new(1, node_2.clone() );

    let head = LinkedNode::new(0,  node_1);
    
    // Move pointer by flat_map
    let safe_fast_pointer = head.clone()
        .and_then(|n| {let n = n.borrow(); n.next.clone() })
        .and_then(|n| {let n = n.borrow(); n.next.clone() });
    
    assert_eq!(safe_fast_pointer, node_2);
    
}
</code></pre>
<p>For another way to use fast and slow pointers without re-implement the LinkedList, see: <a href="https://leetcode.com/problems/middle-of-the-linked-list/solutions/1483630/rust-fastslow-pointer-solution/">link from leetcode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-longest-substring-without-repeating-characters"><a class="header" href="#3-longest-substring-without-repeating-characters">3. Longest Substring Without Repeating Characters</a></h1>
<h2 id="description-of-the-problem-3"><a class="header" href="#description-of-the-problem-3">Description of the Problem</a></h2>
<p>Given a string <code>s</code>, find the length of the longest substring without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;abcabcbb&quot;
Output: 3
Explanation: The answer is &quot;abc&quot;, with the length of 3.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3.
Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>\(0 &lt;= s.length &lt;= 5 * 10^4\)</li>
<li>s consists of English letters, digits, symbols and spaces.</li>
</ul>
<h2 id="solution-3"><a class="header" href="#solution-3">Solution</a></h2>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h3>
<p><strong>Sliding Window</strong></p>
<p>Keep expanding our sliding window to find all substring without repeating character.</p>
<p>If new appended character is repeated, trim the current substring and append the new character.</p>
<p>Suppose before an iteration we have a substring without repeating character <code>AcB</code> where Capital letters represent may-be empty substring and non-capital letter represents 1 character. </p>
<p>If we meet new character <code>d</code> which is different from <code>c</code>, it is fine. Just append to the substring to form a new </p>
<p>Otherwise, if <code>c</code> is the new character, then trim <code>Ac</code> and append <code>c</code>. New Substring becomes <code>Bc</code> which is a valid substring.</p>
<p>The above reasoning illustrates that the algorithm must scan all longest valid substrings. The remaining work is to record the longest one.</p>
<h3 id="code-rust-2"><a class="header" href="#code-rust-2">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn length_of_longest_substring(s: String) -&gt; i32 {
        // Sliding window for longest substring, j is exclusive
        let (mut longest_i, mut longest_j) : (usize, usize) = (0,0);

        // Sliding window for current substring, j is exclusive
        let (mut i, mut j) : (usize, usize)  = (0,0);

        for (k, c) in s.chars().enumerate() {

            // Find 1st index of char c in current substring (&amp;s[i..j])
            // IF new appended character c appear in current substring,
            // i.e. substring has the form of AcBc where current substring consists of substring A, B and character c, 
            // THEN trim is, such that it becomes Bc
            if let Some(index) = (&amp;s[i..j]).find(c){
                i += index + 1; 
            }

            j = k + 1; // the end of the window move right by 1

            // IF the current window size is larger, THEN update.
            if j - i &gt; longest_j - longest_i {
                longest_i = i;
                longest_j = j;
            }
            
        }

        return (longest_j - longest_i) as i32;
    }
} 
</code></pre>
<h3 id="code-java-2"><a class="header" href="#code-java-2">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        if ( s== null || s.isEmpty() ) return 0;

        int start = 0; int end =1;
        int max = 1;

        while( end &lt; s.length() ){
            String subString = s.substring(start, end);
            int indexOfChar = (int) (subString.indexOf(s.charAt(end)));
            if (indexOfChar &gt;= 0){
                start = start + indexOfChar + 1;
            }
            end++;
            max = max &lt; end - start ? end - start : max;
        }

        return max;
    }
}
</code></pre>
<h3 id="complexity-n-is-length-of-the-string"><a class="header" href="#complexity-n-is-length-of-the-string">Complexity (\(n\) is length of the string)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>Worst case: \( T(n) = \mathcal{\Theta}(n^2) \) (String contains no repeating characters)</li>
<li>Average case: \( T(n) = O(n) \) (see <a href="medium-problems/3.html#average-time-complexity-for-the-algorithm">Further Discussion</a>)</li>
<li>Best case: \( T(n) = \mathcal{\Theta}(n) \) (String repeats same character)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(1) \)</li>
<li>Depends on implementation, Rust can achieve \( O(1) \)</li>
</ul>
<h2 id="further-discussion"><a class="header" href="#further-discussion">Further Discussion</a></h2>
<h3 id="average-time-complexity-for-the-algorithm"><a class="header" href="#average-time-complexity-for-the-algorithm">Average Time Complexity for the algorithm</a></h3>
<h4 id="lemma-the-algorithm-run-in--onx--where-n-is-length-of-the-string-and-x-is-number-of-comparsion"><a class="header" href="#lemma-the-algorithm-run-in--onx--where-n-is-length-of-the-string-and-x-is-number-of-comparsion">Lemma: The algorithm run in \( O(n+X) \) where n is length of the string and X is number of comparsion.</a></h4>
<p>Proof: We have n iterations and each iteration performs certain number of character comparsion to find first index of the same character.</p>
<h4 id="theorem-the-expected-number-of-comparsion-is--on-"><a class="header" href="#theorem-the-expected-number-of-comparsion-is--on-">Theorem: The expected number of comparsion is \( O(n) \)</a></h4>
<p>Proof: </p>
<p>Assume \( M \) is the number of characters of the program choose to form a string and each character is equally likely to be chosen independently.</p>
<p>Let \( X_{ij} =  \unicode{x1D7D9}  \text{ { i-th character is compared to j-th character } }   \)</p>
<p>Consider a sequence of characters \( c_i c_{i+1} c_{i+2} ... c_{j-1} \) and a character \( c_j \) in a loop, \( c_i \) and \(c_j\) compares each other if-and-only-if the sequence of characters does not contains repeating characters. Otherwise the substring will be trimmed by our algorithm before the current loop.</p>
<p>The probability of \( c_i c_{i+1} c_{i+2} ... c_{j-1} \) does not contain repeating characters, according to formula of birthday paradox, is \(\frac{M!}{M^{(j-i)} (M - (j - i))! }\)</p>
<p>The total number of comparsion \(\mathbb{E}[X] = \sum_{i = 0}^{n - 2} \sum_{j = i+1}^{n - 1} \mathbb{E}[ X_{ij} ] \)</p>
<p>\(= \sum_{i = 0}^{n - 2} \sum_{j = i+1}^{n - 1} \frac{M!}{M^{(j-i)} (M - (j - i))! } \)</p>
<p>\(= \sum_{i = 0}^{n - 2} \sum_{ k = 1}^{n - 1 - i} \frac{M!}{M^{k} (M - k)! } \)</p>
<p>\( \le \sum_{i = 0}^{n - 2} \sum_{k = 1}^{M} \frac{M!}{M^{k} (M - k)! } \)</p>
<p>\( \le \sum_{i = 0}^{n - 2} \int_{0}^{M} e^{ - x^2 / M^x} dx \ (\because \text{approximation of the &quot;birthday formula&quot;}) \)</p>
<p>\( = \sum_{i = 0}^{n - 2} \frac{M\sqrt{\pi}}{2} \)</p>
<p>\( = (n-1) \frac{M\sqrt{\pi}}{2} \)</p>
<p>\( = (n-1) \frac{95 \cdot \sqrt{\pi}}{2} \ (\because \text{according to ASCII table, Dec32 to Dec126 are the characters the Leetcode program will choose}) \)</p>
<p>\( \approx (n-1) 149 \)</p>
<p>\( = O(n) \)</p>
<h4 id="corollary-the-average-running-time-of-the-algorithm-is-on"><a class="header" href="#corollary-the-average-running-time-of-the-algorithm-is-on">Corollary: The average running time of the algorithm is \(O(n)\)</a></h4>
<p>Followed by the lemma and theorem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="151-reverse-words-in-a-string"><a class="header" href="#151-reverse-words-in-a-string">151. Reverse Words in a String</a></h1>
<h2 id="description-of-the-problem-4"><a class="header" href="#description-of-the-problem-4">Description of the Problem</a></h2>
<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>
<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in s will be separated by at least one space.</p>
<p>Return <em>a string of the words in reverse order concatenated by a single space</em>.</p>
<p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;the sky is blue&quot;
Output: &quot;blue is sky the&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;  hello world  &quot;
Output: &quot;world hello&quot;
Explanation: Your reversed string should not contain leading or trailing spaces.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot;a good   example&quot;
Output: &quot;example good a&quot;
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces ' '.</li>
<li>There is at least one word in <code>s</code>.</li>
</ul>
<p>Follow-up: If the string data type is mutable in your language, can you solve it in-place with <code>O(1)</code> extra space?</p>
<h2 id="solution-4"><a class="header" href="#solution-4">Solution</a></h2>
<p>Simple Idea:</p>
<ul>
<li>To reverse each word in a string, do mirroring to each word and then do mirroring to the whole string.</li>
<li>To do mirroring for each word, we have to scan each word (using sliding windows, i.e. tokenise)</li>
<li>The follow-up question requires us to do almost any operations in-place. We can first copy each token to suitable place by sliding windows method. For example, <code>____ABC</code> becomes <code>ABC_ABC</code>.</li>
</ul>
<p>Reminder:</p>
<ul>
<li>(*) To fullfill the follow-up question, do not create too much copy of the <code>String</code>. Keep in mind that even if some methods/functions do not have <code>new</code> keyword, the code behind these methods/functions may contain <code>new</code> keyword in their implementation (i.e. they use extra space). For example, in Java, <code>.substring(i, j)</code> will create new <code>String</code> in Heap. To know more about this, please look at the source code. 
<ul>
<li>Rust provides source code in their offcial website. </li>
<li>You can also look at the source code of Java via IDE.</li>
</ul>
</li>
<li>In my opinion, the key idea of the problems is to illistrate you are able to acheive \( O(1) \) conceptually. It is not necessary to implement it so carefully.</li>
</ul>
<p><strong>My definition to &quot;extra/auxiliary space&quot; is excluding input space and output space</strong></p>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h3>
<h3 id="code-rust-3"><a class="header" href="#code-rust-3">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn reverse_words(s: String) -&gt; String {
        let space_in_u8 = 32;

        // According to RustDoc: &quot;This consumes the `String`, so we do not need to copy its contents&quot;
        // i.e. convert it into Vec&lt;u8&gt; costs O(1) Space
        let mut v = s.into_bytes();

        // i, j for sliding window,
        // k is location of cell to be filled-in
        let (mut i, mut j, mut k, n) = (0,0,0,v.len());
        while j &lt; n {
            match (v[i] == space_in_u8, v[j]==space_in_u8){

                // Case 1: Sliding window contains only space, move two pointers
                (true, true) =&gt; {i+=1; j+=1;},

                // Impossible case
                (true, false) =&gt; {panic!(&quot;Reaches impossible case&quot;);},

                // Case 2: sliding window complete the scanning of a word
                (false, true) =&gt; {

                    // If the &quot;current result&quot; has some word, append space
                    if k &gt; 0 {
                        v[k] = space_in_u8;
                        k+=1;
                    }

                    // v[k..k+j-i] = v[i..j].reverse()
                    Solution::copy_and_reverse(&amp;mut v, i, j, &amp;mut k);

                    // reset pointer location by right j by 1, i points to where j locates
                    j+=1;
                    i=j;
                },

                // Case 3: Sliding window contains only characters
                // It may not complete the scanning
                (false, false) =&gt; {
                    j+=1;
                    // If j reaches the end of string, do copy_and_reverse
                    if j == n {
                        if k &gt; 0 {
                            v[k] = space_in_u8;
                            k+=1;
                        }
                        Solution::copy_and_reverse(&amp;mut v, i, j, &amp;mut k);
                    }
                }

            }
        }

        v.truncate(k); // cut unnecessary characters 
        Solution::reverse_string(&amp;mut v, 0, k); // reverse the whole string

        // Convert Vec&lt;u8&gt; back to String
        // It costs O(1) according to String implmentation (see source code of Rust)
        // i.e. give ownership of Vec&lt;u8&gt; to String Struct
        return unsafe { String::from_utf8_unchecked(v) }; 
    }

    // v[k..k+j-i] = v=[i..j].reverse()
    fn copy_and_reverse(v: &amp;mut Vec&lt;u8&gt;, begin: usize, end: usize, k: &amp;mut usize){
        let k_origin = *k;

        // v[k..k+j-i] = v=[i..j]
        for i in (begin..end){
            v[*k] = v[i];
            *k +=1;
        }

        Solution::reverse_string(v, k_origin, k_origin+end-begin);
    }

    // v[k..k+j-i].reverse()
    fn reverse_string(v: &amp;mut Vec&lt;u8&gt;, begin: usize, end: usize){
        let (mut i, mut j) = (begin, end - 1);
        while i &lt; j {
            let tmp = v[i];
            v[i] = v[j];
            v[j] = tmp;
            i+=1;
            j-=1;
        }
    }
}
</code></pre>
<h3 id="complexity-n-is-length-of-the-string-1"><a class="header" href="#complexity-n-is-length-of-the-string-1">Complexity (\(n\) is length of the string)</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( O(n) \)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(1) \)
<ul>
<li>Depends on Programming Language and implementation</li>
<li>Conceptually it can acheive O(1) Space</li>
</ul>
</li>
</ul>
<h2 id="further-discussion-1"><a class="header" href="#further-discussion-1">Further Discussion</a></h2>
<h3 id="limitation-of-a-programming-language-and-turing-equivalence"><a class="header" href="#limitation-of-a-programming-language-and-turing-equivalence">Limitation of a Programming Language and Turing Equivalence(?)</a></h3>
<p>Some people argue that each language has its limitation. For instance, Java cannot actually acheive \(O(1)\) extra space in this problem. To some extent, I will agree. Theoretically, however, if each programming language simluates <strong>Universal Turing Machine</strong>, they should be equivalent. This implies that there is no operation Rust can do but Java can't. The only matter is the cost for one language to simulate another. Just like to simulates Two-Tape Turing Machine by the One-Tape, we need more steps/operations in One-Tape Turing Machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="65-valid-number"><a class="header" href="#65-valid-number">65. Valid Number</a></h1>
<h2 id="description-of-the-problem-5"><a class="header" href="#description-of-the-problem-5">Description of the Problem</a></h2>
<p>A <strong>valid number</strong> can be split up into these components (in order):</p>
<ol>
<li>A <strong>decimal number</strong> or an <strong>integer</strong>.</li>
<li>(Optional) An <code>'e'</code> or <code>'E'</code>, followed by an integer.</li>
</ol>
<p>A <strong>decimal number</strong> can be split up into these components (in order):</p>
<ol>
<li>(Optional) A sign character (either <code>'+'</code> or <code>'-'</code>).</li>
<li>One of the following formats:
<ol>
<li>One or more digits, followed by a dot <code>'.'</code>.</li>
<li>One or more digits, followed by a dot <code>'.'</code>, followed by one or more digits.</li>
<li>A dot <code>'.'</code>, followed by one or more digits.</li>
</ol>
</li>
</ol>
<p>An <strong>integer</strong> can be split up into these components (in order):</p>
<ol>
<li>(Optional) A sign character (either <code>'+'</code> or <code>'-'</code>).</li>
<li>One or more digits.</li>
</ol>
<p>For example, all the following are valid numbers: <code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;], while the following are not valid numbers: [&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code>.</p>
<p>Given a string <code>s</code>, return <code>true</code> if <code>s</code> is a valid number.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;0&quot;
Output: true
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;e&quot;
Output: false
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot;.&quot;
Output: false
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>'+'</code>, minus <code>'-'</code>, or dot <code>'.'</code>.</li>
</ul>
<h2 id="solution-5"><a class="header" href="#solution-5">Solution</a></h2>
<p>For any problem about format. I suggest every one first to write a <strong>Extended Backus-Naur Form</strong> or <strong>Regular Expression</strong> to represent correct format.</p>
<p>We can split the string by special char such as <code>e</code>, <code>E</code> and <code>.</code> and check the validity of substrings.</p>
<h3 id="explanation-5"><a class="header" href="#explanation-5">Explanation</a></h3>
<h4 id="extended-backus-naur-form-of-valid-number"><a class="header" href="#extended-backus-naur-form-of-valid-number">Extended Backus-Naur Form of Valid Number</a></h4>
<p>\( \langle goal \rangle ::= (\text{'+'} | \text{'-'})? \langle base \rangle  ((\text{'e'}|\text{'E'})?\langle  expo \rangle )? \)</p>
<p>\(\langle  expo \rangle ::= (\text{'+'} | \text{'-'})? \langle  digits \rangle \)</p>
<p>\(\langle  base \rangle ::= \langle  digits \rangle \)</p>
<p>\( \ | \langle  digits \rangle  \text{'.'}  \)</p>
<p>\( \ | \ \text{'.'} \langle  digits \rangle \)</p>
<p>\( \ |  \langle  digits \rangle  \text{'.'} \langle  digits \rangle  \)</p>
<p>\( \langle  digits \rangle ::= (\text{'0'} | \text{'1'} | ... | \text{'9'})^+  \)</p>
<h3 id="code-rust-4"><a class="header" href="#code-rust-4">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {

    fn split_at_char(s: &amp;str, v : char) -&gt; (&amp;str, &amp;str){
        let option_index = s.find(v);

        return match option_index {
            Some(index) =&gt; {
                let len = s.len();

                // Exclude the character we found
                return (&amp;s[0..index], &amp;s[index+1..len]);
            },
            None =&gt; (s, &amp;&quot;&quot;),
        }

    }

    #[inline]
    fn process_first_char( s : &amp;str) -&gt; &amp;str{
        return if s.len() &gt; 0 {
            if s[0..1].find(&quot;+&quot;).is_some() || s[0..1].find(&quot;-&quot;).is_some() {&amp;s[1..]} else {s}
        }
        else {
            s
        };
    }

    fn is_digits(s: &amp;str, is_empty_true : bool) -&gt; bool{
        for c in s.chars() {
            match c {
                '0'..='9' =&gt; {},
                _ =&gt; {return false;},
            }
        }

        return if s == &quot;&quot; { is_empty_true } else { true };
    }

    fn is_signed_digits(s: &amp;str, is_empty_true : bool) -&gt; bool{
        let s = Solution::process_first_char(s);
        return Solution::is_digits(s, is_empty_true);
    }

    // Principal function of Solution
    pub fn is_number(s: String) -&gt; bool {
        if s.len() == 0 {
            return false;
        }

        let s = Solution::process_first_char(&amp;s);

        // Determine 'e' or 'E'
        let char_e = match ( s.find('e'), s.find('E') ) {
            (None,None) =&gt; { '\0' }, // dummy value
            (None,Some(_)) =&gt; { 'E' },
            (Some(_),None) =&gt; { 'e' },
            (Some(_),Some(_)) =&gt; { 'e' },
        };

        let (base, expo) = Solution::split_at_char(s, char_e);
        let (lhs, rhs) = Solution::split_at_char(base, '.');

        let (has_dot, has_e) = (
                s.find('.').is_some(),
                s.find('e').is_some() || s.find('E').is_some()
        );

        return match (has_dot, has_e) {

            // Case: &lt;base&gt; ('e'|'E') &lt;expo&gt;
            (true, true) =&gt;
                (lhs.len() &gt; 0 || rhs.len() &gt; 0) &amp;&amp;
                Solution::is_digits(lhs, true) &amp;&amp;
                Solution::is_digits(rhs, true) &amp;&amp;
                Solution::is_signed_digits(expo, false),

            // Case: &lt;lhs&gt;? '.' &lt;rhs&gt;?
            //      =&gt; &lt;lhs&gt; '.' &lt;rhs&gt;
            //      =&gt; '.' &lt;rhs&gt;
            //      =&gt; &lt;lhs&gt; '.'
            (true, false) =&gt;
                (lhs.len() &gt; 0 || rhs.len() &gt;0) &amp;&amp;
                Solution::is_digits(lhs, true) &amp;&amp;
                Solution::is_digits(rhs, true),

            // Case: &lt;base&gt; ('e'|'E') &lt;expo&gt;
            (false, true) =&gt;
                Solution::is_digits(lhs, false) &amp;&amp;
                Solution::is_signed_digits(expo, false),

            // Case: &lt;base&gt;
            (false, false) =&gt; Solution::is_digits(lhs, false),

        };
    }

}
</code></pre>
<h3 id="complexity-n-is-the-length-of-string"><a class="header" href="#complexity-n-is-the-length-of-string">Complexity (n is the length of string)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>T(n) = O(n)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>S(n) = O(1)</li>
</ul>
<h2 id="further-discussion-2"><a class="header" href="#further-discussion-2">Further Discussion</a></h2>
<p>It is not difficult to see that this type of problems (i.e. Parsing) can be easily to solved by Haskell (Especially if we use Parser library such as <code>ParSec</code>). If I were an interviewee I would argue that it is suitable to use functional programming language instead of the imperative one.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
