<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Leetbook</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Solutions</li><li class="chapter-item expanded "><div>Easy</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="easy-problems/1.html">1. Two Sum</a></li><li class="chapter-item expanded "><a href="easy-problems/70.html">70. Climbing Stairs</a></li><li class="chapter-item expanded "><a href="easy-problems/206.html">206. Reverse Linked Lists</a></li><li class="chapter-item expanded "><a href="easy-problems/234.html">234. Palindrome Linked List</a></li><li class="chapter-item expanded "><a href="easy-problems/876.html">876.	Middle of the Linked List</a></li></ol></li><li class="chapter-item expanded "><div>Medium</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="medium-problems/2.html">2. Add Two Numbers</a></li><li class="chapter-item expanded "><a href="medium-problems/3.html">3. Longest Substring Without Repeating Characters</a></li><li class="chapter-item expanded "><a href="medium-problems/6.html">6. Zigzag Conversion</a></li><li class="chapter-item expanded "><a href="medium-problems/7.html">7. Reverse Integer</a></li><li class="chapter-item expanded "><a href="medium-problems/17.html">17. Letter Combination of a Phone Number</a></li><li class="chapter-item expanded "><a href="medium-problems/24.html">24. Swap Nodes in Pairs</a></li><li class="chapter-item expanded "><a href="medium-problems/50.html">50. Pow(x, n)</a></li><li class="chapter-item expanded "><a href="medium-problems/55.html">55. Jump Game</a></li><li class="chapter-item expanded "><a href="medium-problems/78.html">78. Subsets</a></li><li class="chapter-item expanded "><a href="medium-problems/98.html">98. Validate Binary Search Tree</a></li><li class="chapter-item expanded "><a href="medium-problems/113.html">113. Path Sum II</a></li><li class="chapter-item expanded "><a href="medium-problems/143.html">143. Reorder List</a></li><li class="chapter-item expanded "><a href="medium-problems/150.html">150. Evaluate Reverse Polish Notation</a></li><li class="chapter-item expanded "><a href="medium-problems/151.html">151. Reverse Words in a String</a></li><li class="chapter-item expanded "><a href="medium-problems/179.html">179. Largest Number</a></li><li class="chapter-item expanded "><a href="medium-problems/322.html">322. Coin Change</a></li><li class="chapter-item expanded "><a href="medium-problems/347.html">347. Top K Frequent Elements</a></li><li class="chapter-item expanded "><a href="medium-problems/371.html">371. Sum of Two Integers</a></li><li class="chapter-item expanded "><a href="medium-problems/518.html">518. Coin Change II</a></li><li class="chapter-item expanded "><a href="medium-problems/435.html">435. Non-overlapping Intervals</a></li><li class="chapter-item expanded "><a href="medium-problems/2095.html">2095. Delete the Middle Node of a Linked List</a></li></ol></li><li class="chapter-item expanded "><div>Hard</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hard-problems/60.html">60. Permutation Sequence</a></li><li class="chapter-item expanded "><a href="hard-problems/65.html">65. Valid Number</a></li><li class="chapter-item expanded "><a href="hard-problems/239.html">239. Sliding Window Maximum</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Solutions w/o explanation</li><li class="chapter-item expanded "><div>Easy</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="easy-problems-no-explain/9.html">9. Palindrome Number</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/20.html">20. Valid Parentheses</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/21.html">21. Merge Two Sorted Lists</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/26.html">26. Remove Duplicates from Sorted Array</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/83.html">83. Remove Duplicates from Sorted List</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/94.html">94. Binary Tree Inorder Traversal</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/100.html">100. Same Tree</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/111.html">111. Minimum Depth of Binary Tree</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/112.html">112. Path Sum</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/118.html">118. Pascal's Triangle</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/125.html">125. Valid Palindrome</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/141.html">141. Linked List Cycle</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/144.html">144. Binary Tree Preorder Traversal</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/145.html">145. Binary Tree Postorder Traversal</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/191.html">191. Number of 1 Bits</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/193.html">193. Valid Phone Numbers</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/195.html">195. Tenth Line</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/217.html">217. Contains Duplicate</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/226.html">226. Invert Binary Tree</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/292.html">292. Nim Game</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/231.html">231. Power of Two</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/344.html">344. Reverse String</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/374.html">374. Guess Number Higher or Lower</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/897.html">897. Increasing Order Search Tree</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/1290.html">1290. Convert Binary Number in a Linked List to Integer</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/1822.html">1822. Sign of the Product of an Array</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/1929.html">1929. Concatenation of Array</a></li><li class="chapter-item expanded "><a href="easy-problems-no-explain/2331.html">2331. Evaluate Boolean Binary Tree</a></li></ol></li><li class="chapter-item expanded "><div>Medium</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="medium-problems-no-explain/19.html">19. Remove Nth Node From End of List</a></li><li class="chapter-item expanded "><a href="medium-problems-no-explain/46.html">46. Permutations</a></li><li class="chapter-item expanded "><a href="medium-problems-no-explain/207.html">207. Course Schedule</a></li><li class="chapter-item expanded "><a href="medium-problems-no-explain/210.html">210. Course Schedule II</a></li><li class="chapter-item expanded "><a href="medium-problems-no-explain/237.html">237. Delete Node in a Linked List</a></li></ol></li><li class="chapter-item expanded "><div>Hard</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hard-problems-no-explain/68.html">68. Text Justification</a></li><li class="chapter-item expanded "><a href="hard-problems-no-explain/295.html">295. Find Median from Data Stream</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Leetbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to my book for leetcode problems. Here you can find meaningful problems from Leetcode and my explantions of solutions.</p>
<h2 id="programming-language-used-in-solutions"><a class="header" href="#programming-language-used-in-solutions">Programming Language used in solutions</a></h2>
<ul>
<li>Rust</li>
<li>Java (Sometimes replaced by C++)</li>
</ul>
<h2 id="kind-reminder"><a class="header" href="#kind-reminder">Kind Reminder</a></h2>
<ul>
<li>The book is not completed yet. I am still writing explanations for problems.</li>
<li>The web will be <strong>updated very slowly</strong> because explaining each solved problem will be time-consuming.</li>
<li>Some of problems have only simple explanation as the code explains itself.</li>
<li>Some of explanations and solutions may not be correct. Espectially for the complexity of an algorithm. Sometimes I do not use rigorous calculation/proof.</li>
</ul>
<h2 id="update-notes"><a class="header" href="#update-notes">Update Notes</a></h2>
<ul>
<li>Last Updated: 2024.Jan.02
<ul>
<li>Add Solutions:
<ul>
<li><a href="medium-problems/6.html">6. Zigzag Conversion</a></li>
<li><a href="medium-problems/55.html">55. Jump Game</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-two-sum"><a class="header" href="#1-two-sum">1. Two Sum</a></h1>
<h2 id="description-of-the-problem"><a class="header" href="#description-of-the-problem">Description of the Problem</a></h2>
<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>You can return the answer in any order.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [3,2,4], target = 6
Output: [1,2]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: nums = [3,3], target = 6
Output: [0,1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>\(2 &lt;= nums.length &lt;= 10^4\)</li>
<li>\(-10^9 &lt;= nums[i] &lt;= 10^9\)</li>
<li>\(-10^9 &lt;= target &lt;= 10^9\)</li>
<li>Only one valid answer exists.</li>
</ul>
<p>Follow-up: Can you come up with an algorithm that is less than \(O(n^2)\) time complexity?</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<p>\( \text{IF} \ num[i]+num[j]==target \ \text{THEN} \ return [i,j] \)</p>
<p>\( \Longleftrightarrow \)</p>
<p>\( \text{IF} \ num[i]==target - num[j] \ \text{THEN} \  return [i,j] \)</p>
<h3 id="code-rust"><a class="header" href="#code-rust">Code (Rust)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

impl Solution {
    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {
        let mut hashMap = HashMap::new();

        for i in 0..nums.len(){
            let complement = target - nums[i];
            if hashMap.contains_key(&amp;complement){
                return vec![
                    i as i32 , hashMap[&amp;complement] as i32
                ];
            }
            hashMap.insert(nums[i], i);
        }
        return vec![];
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="code-java"><a class="header" href="#code-java">Code (Java)</a></h3>
<pre><code class="language-java">import java.util.HashMap;

public class Solution_2 {
    public int[] twoSum(int [] nums, int target){

        // It stores (num-&gt;index)
        HashMap &lt;Integer,Integer&gt; hashmap = new HashMap();

        for(int i = 0; i &lt; nums.length; i++){
            int complement = target - nums[i];
            if ( hashmap.containsKey(complement) ){
                return new int[] { hashmap.get(complement), i};
            }
            hashmap.put(nums[i], i);
        }

        return null;
    }

}
</code></pre>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<p><strong>Time complexity: \(n is length of nums\)</strong></p>
<ul>
<li>\( T(n) = O(n) \)
<ul>
<li>Assume hashMap get/put use constant time</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(2n) \)
<ul>
<li>It store at most 2n (key and value) elements in HashMap</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="70-climbing-stairs"><a class="header" href="#70-climbing-stairs">70. Climbing Stairs</a></h1>
<h2 id="description-of-the-problem-1"><a class="header" href="#description-of-the-problem-1">Description of the Problem</a></h2>
<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>
<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>1 &lt;= n &lt;= 45</li>
</ul>
<h2 id="solution-1"><a class="header" href="#solution-1">Solution</a></h2>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h3>
<p>Consider climbing a n-step stairs, how many possible ways can we climb to the top. We have two possible move; either move 1 step or 2 step. </p>
<p>Thus the problem becomes finding the sum of the number of ways in (n-1)-step staircase and in (n-2)-step staircase. (see the following equations)</p>
<p>\[ 
\begin{align}
w_0 = &amp; \ 1 \\
w_1 = &amp; \ 1 \\
w_n = &amp; \ w_{n-1} + w_{n-2} \\
\end{align}
\]</p>
<h3 id="code-rust-1"><a class="header" href="#code-rust-1">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn climb_stairs(n: i32) -&gt; i32 {
        let n = n as usize;
        let mut dp = vec![0; n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for i in 2..=n{
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n] as i32;
    }
}
</code></pre>
<h3 id="complexity-1"><a class="header" href="#complexity-1">Complexity</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( T(n) = \Theta(n) \)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = \Theta(n) \)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="206-reverse-linked-lists"><a class="header" href="#206-reverse-linked-lists">206. Reverse Linked Lists</a></h1>
<h2 id="description-of-the-problem-2"><a class="header" href="#description-of-the-problem-2">Description of the Problem</a></h2>
<p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2]
Output: [2,1]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: head = []
Output: []
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<h2 id="solution-2"><a class="header" href="#solution-2">Solution</a></h2>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h3>
<p>The following (Rust) code can be verified by the loop invariant </p>
<p>Invariant: All nodes before the current node are properly reversed</p>
<p>Proof: </p>
<ul>
<li>Initialisation: Before the begin of the loop, No node is before the current node, the invariant is vacuously true</li>
<li>Maintenance: Suppose the invariant is true before an iteration, having perform re-ordering operations, all nodes before the current node (originally it is next node) is properly reversed</li>
<li>Termination: After all iterations, all nodes in the LinkedList are reversed properly</li>
</ul>
<h3 id="code-rust-2"><a class="header" href="#code-rust-2">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -&gt; Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }


impl Solution {
    pub fn reverse_list(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut curr = head;
        let mut prev = None;

        while let Some(mut node) = curr.take() {
            curr = node.next; // Transfer the ownership of node.next to curr, node.next becomes None
            node.next = prev; // The next node of the current node should point to previous node
            prev = Some(node); // Current nodebecomes preivous node for next iteration
        }

        return prev;
    }
}
</code></pre>
<h3 id="codejava"><a class="header" href="#codejava">Code(Java)</a></h3>
<pre><code class="language-Java">public class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;

        while(curr != null){
            ListNode temp = curr;
            curr = temp.next;
            temp.next = prev;
            prev= temp;
        }

        return prev;
    }
}
</code></pre>
<h3 id="codec"><a class="header" href="#codec">Code(C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode * prev = nullptr;
        ListNode * curr = head;
        ListNode * node;
        while( (node = curr) != nullptr ){
            curr = node-&gt;next;
            node-&gt;next = prev;
            prev = node;
        }
        return prev;
    }
};
</code></pre>
<h3 id="complexity-2"><a class="header" href="#complexity-2">Complexity</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( T(n) = \mathcal{\Theta}(n) \)
<ul>
<li>Traversal of all nodes in LinkedList</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(1) \)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="234-palindrome-linked-list"><a class="header" href="#234-palindrome-linked-list">234. Palindrome Linked List</a></h1>
<h2 id="description-of-problem"><a class="header" href="#description-of-problem">Description of Problem</a></h2>
<p>Given the head of a singly linked list, return <code>true</code> if it is a <em>palindrome</em> or <code>false</code> otherwise.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,2,2,1]
Output: true
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2]
Output: false
</code></pre>
<p><strong>Constraints</strong>:</p>
<ul>
<li>The number of nodes in the list is in the range <code>[1, 105]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p><strong>Follow up</strong>: Could you do it in O(n) time and O(1) space?</p>
<h2 id="solution-3"><a class="header" href="#solution-3">Solution</a></h2>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h3>
<p>If you solve [<a href="easy-problems/medium-problems/143.html">143. Reorder List</a>], it is not difficult to re-use the logic.</p>
<h3 id="code-c"><a class="header" href="#code-c">Code (C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;

        // 1. Find the middle node
        while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr){
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }

        // 2. Cut and Reverse
        ListNode* curr = slow-&gt;next; 
        ListNode* prev = nullptr;
        slow-&gt;next = nullptr; // Cut

        // Reverse
        while(curr != nullptr){
            ListNode* temp = curr;
            curr = temp-&gt;next;
            temp-&gt;next = prev;
            prev = temp;
        }

        // 3. Merge
        ListNode* list1 = head; ListNode* list2 = prev;
        while(list1 != nullptr &amp;&amp; list2 != nullptr){
            if (list1-&gt;val != list2-&gt;val){
                return false;
            }
            list1 = list1-&gt;next;
            list2 = list2-&gt;next;
        }

        return true;
    }
};
</code></pre>
<h3 id="complexity-3"><a class="header" href="#complexity-3">Complexity</a></h3>
<p>Time complexity:</p>
<ul>
<li>\(T(n)=O(n)\)
<ul>
<li>There are only nearly constant number of n iterations</li>
</ul>
</li>
</ul>
<p>Auxiliary Space:</p>
<ul>
<li>\(S(n)=O(1)\)
<ul>
<li>Use only constant number of variables</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="876-middle-of-the-linked-list"><a class="header" href="#876-middle-of-the-linked-list">876.	Middle of the Linked List</a></h1>
<h2 id="description-of-the-problem-3"><a class="header" href="#description-of-the-problem-3">Description of the Problem</a></h2>
<p>Given the <code>head</code> of a singly linked list, return the middle node of the linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is in the range <code>[1, 100]</code>.</li>
<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="solution-4"><a class="header" href="#solution-4">Solution</a></h2>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h3>
<p><strong>Fast and Slow Pointers</strong></p>
<p>Slow pointer move to right by 1 and fast pointer move to right by 2 if possible.</p>
<p>At the end of loop, slow pointer must point to the middle node or previous node of the middle node</p>
<p>Here we assume the linkedlist use 0-based indexing (i.e. list[0] indicate first element of the list)</p>
<p>At the termination of the loop, there are only two possible case:</p>
<ol>
<li>fast pointer point to <strong>last</strong> element of the linkedlist</li>
<li>fast pointer point to <strong>second last</strong> element of the linkedlist;</li>
</ol>
<p>Suppose the loop ran <code>k</code> times. It implies that fast pointer mvoed to right by <code>2k</code> and slow pointer moved to right by <code>k</code>.</p>
<p>In case 1, this is because the number of nodes in the linkedlist is odd number. The total number of nodes is <code>2k + 1</code>. <code>list[k]</code> is the middle node because there are <code>k</code> elements in <code>list[0..k]</code> and in <code>list[k+1..2k+1]</code> elements<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<p>In case 2, this is becuase the number of nodes in the linkedlist is even number. The total number of nodes is 2k + 2. <code>list[0..k]</code> and <code>list[k+1..2k+2]</code> contains half number of total elements.<sup class="footnote-reference"><a href="#1">1</a></sup> Thus return slow.next;</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> The sub-indexing is exclusive. For example<code> A[i..j]</code> does not include <code>A[j]</code></p>
<h3 id="code-java-1"><a class="header" href="#code-java-1">Code (Java)</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null &amp;&amp; fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return fast.next == null? slow : slow.next;
    }
}
</code></pre>
<h3 id="complexity-4"><a class="header" href="#complexity-4">Complexity</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( T(n) = O(n/2) \)
<ul>
<li>There are only nearly n/2 iterations</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(1) \)
<ul>
<li>Use only constant number of variables</li>
</ul>
</li>
</ul>
<h2 id="futher-discussion"><a class="header" href="#futher-discussion">Futher Discussion</a></h2>
<h3 id="alternative-way-to-implements-linkedlist-in-rust-and-how-to-move-a-pointer-in-rust"><a class="header" href="#alternative-way-to-implements-linkedlist-in-rust-and-how-to-move-a-pointer-in-rust">Alternative way to implements LinkedList in Rust and How to move a pointer in Rust</a></h3>
<p>Althougt it is possible to implement LinkedList in Rust by <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>, I do not know why leetcode refuse to use it. I would like to provide another implementation that supports fast and slow pointers approach. The key difficulty is moving pointer.</p>
<pre><code class="language-Rust">use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug, PartialEq)]
struct LinkedNode {
    val : i32,
    next : Option&lt;Rc&lt;RefCell&lt;LinkedNode&gt;&gt;&gt;,
}

impl LinkedNode {
    fn new(val : i32, next: Option&lt;Rc&lt;RefCell&lt;LinkedNode&gt;&gt;&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;LinkedNode&gt;&gt;&gt;{
        Some(
            Rc::new(
                RefCell::new(
                    LinkedNode{
                        val, 
                        next
                    }
                )
            )
        )
    }
}

fn main() {

    let node_2 = LinkedNode::new(2, None);
    let node_1 = LinkedNode::new(1, node_2.clone() );

    let head = LinkedNode::new(0,  node_1);
    
    // Move pointer by flat_map
    let safe_fast_pointer = head.clone()
        .and_then(|n| {let n = n.borrow(); n.next.clone() })
        .and_then(|n| {let n = n.borrow(); n.next.clone() });
    
    assert_eq!(safe_fast_pointer, node_2);
    
}
</code></pre>
<p>For another way to use fast and slow pointers without re-implement the LinkedList, see: <a href="https://leetcode.com/problems/middle-of-the-linked-list/solutions/1483630/rust-fastslow-pointer-solution/">link from leetcode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-add-two-numbers"><a class="header" href="#2-add-two-numbers">2. Add Two Numbers</a></h1>
<h2 id="description-of-the-problem-4"><a class="header" href="#description-of-the-problem-4">Description of the Problem</a></h2>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: l1 = [0], l2 = [0]
Output: [0]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>
</ul>
<h2 id="solution-5"><a class="header" href="#solution-5">Solution</a></h2>
<h3 id="explanation-5"><a class="header" href="#explanation-5">Explanation</a></h3>
<p>The following codes(Java/C++) explains themselves.</p>
<h3 id="code-rust-3"><a class="header" href="#code-rust-3">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -&gt; Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn reverse_list(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut curr = head;
        let mut prev = None;

        while let Some(mut node) = curr.take() {
            curr = node.next;
            node.next = prev;
            prev = Some(node);
        }

        return prev;
    }

    pub fn add_two_numbers(l1: Option&lt;Box&lt;ListNode&gt;&gt;, l2: Option&lt;Box&lt;ListNode&gt;&gt;) 
        -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut carry : i32 = 0;
        let mut l1 = l1;
        let mut l2 = l2;
        let mut curr = Some(Box::new(ListNode::new(0))); // Dummy head


        while l1.is_some() || l2.is_some() || carry &gt; 0
        {
            let mut sum = carry;
            if let Some(node) = l1 {
                sum += node.val;
                l1 = node.next;
            }

            if let Some(node) = l2 {
                sum += node.val;
                l2 = node.next;
            }

            let mut node = ListNode::new(sum % 10);
            node.next = curr;
            curr = Some(Box::new(node));
            carry = sum / 10;
        }

        curr = Solution::reverse_list(curr);
        
        if let Some(node) = curr {
            curr = node.next;
        }

        return curr;
    }
}
</code></pre>
<h3 id="code-java-2"><a class="header" href="#code-java-2">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode result = new ListNode(0); // Sentinel node
        ListNode current = result;
        int carry = 0;
        while (l1 != null || l2 != null || carry &gt; 0) {
            int sum = carry;
            if (l1 != null){
                sum += l1.val;
                l1 = l1.next;
            }

            if (l2 != null){
                sum += l2.val;
                l2 = l2.next;
            }

            carry = sum / 10;
            current.next = new ListNode(sum % 10);
            current = current.next;
        }
        return result.next;
    }
}
</code></pre>
<h3 id="code-c-1"><a class="header" href="#code-c-1">Code (C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode * dummyHead = new ListNode();
        ListNode * curr = dummyHead;
        
        int carry = 0;

        while( l1 != nullptr || l2 != nullptr || carry &gt; 0){
                int val = 
                    (l1 != nullptr ? l1-&gt;val : 0) +
                    (l2 != nullptr ? l2-&gt;val : 0) +
                    carry;
                carry = val &gt;= 10 ? 1 : 0;
                curr-&gt;next = new ListNode( val % 10 );
                
                curr = curr-&gt;next;
                l1 = (l1 == nullptr) ? nullptr : l1-&gt;next;
                l2 = (l2 == nullptr) ? nullptr : l2-&gt;next;
        }
        return dummyHead-&gt;next;
    }
};
</code></pre>
<h3 id="complexity-m-is-the-length-of-list1-and-n-is-the-length-of-list2"><a class="header" href="#complexity-m-is-the-length-of-list1-and-n-is-the-length-of-list2">Complexity (m is the length of list1 and n is the length of list2)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\(O(\max(m,n)+1)\)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(1) \)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-longest-substring-without-repeating-characters"><a class="header" href="#3-longest-substring-without-repeating-characters">3. Longest Substring Without Repeating Characters</a></h1>
<h2 id="description-of-the-problem-5"><a class="header" href="#description-of-the-problem-5">Description of the Problem</a></h2>
<p>Given a string <code>s</code>, find the length of the longest substring without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;abcabcbb&quot;
Output: 3
Explanation: The answer is &quot;abc&quot;, with the length of 3.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3.
Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>\(0 &lt;= s.length &lt;= 5 * 10^4\)</li>
<li>s consists of English letters, digits, symbols and spaces.</li>
</ul>
<h2 id="solution-6"><a class="header" href="#solution-6">Solution</a></h2>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation</a></h3>
<p><strong>Sliding Window</strong></p>
<p>Keep expanding our sliding window to find all substring without repeating character.</p>
<p>If new appended character is repeated, trim the current substring and append the new character.</p>
<p>Suppose before an iteration we have a substring without repeating character <code>AcB</code> where Capital letters represent may-be empty substrings and non-capital letter represents 1 character. </p>
<p>If we meet new character <code>d</code> which is different from <code>c</code>, it is fine. Just append to the substring to form a new </p>
<p>Otherwise, if <code>c</code> is the new character, then trim <code>Ac</code> and append <code>c</code>. New Substring becomes <code>Bc</code> which is a valid substring.</p>
<p>The above reasoning show that the algorithm must scan all longest possible valid substrings. The remaining work is to record the longest one.</p>
<h3 id="code-rust-4"><a class="header" href="#code-rust-4">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn length_of_longest_substring(s: String) -&gt; i32 {
        // Sliding window for longest substring, j is exclusive
        let (mut longest_i, mut longest_j) : (usize, usize) = (0,0);

        // Sliding window for current substring, j is exclusive
        let (mut i, mut j) : (usize, usize)  = (0,0);

        for (k, c) in s.chars().enumerate() {

            // Find 1st index of char c in current substring (&amp;s[i..j])
            // IF new appended character c appear in current substring,
            // i.e. substring has the form of AcBc where current substring consists of substring A, B and character c, 
            // THEN trim is, such that it becomes Bc
            if let Some(index) = (&amp;s[i..j]).find(c){
                i += index + 1; 
            }

            j = k + 1; // the end of the window move right by 1

            // IF the current window size is larger, THEN update.
            if j - i &gt; longest_j - longest_i {
                longest_i = i;
                longest_j = j;
            }
            
        }

        return (longest_j - longest_i) as i32;
    }
} 
</code></pre>
<h3 id="code-java-3"><a class="header" href="#code-java-3">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        if ( s== null || s.isEmpty() ) return 0;

        int start = 0; int end =1;
        int max = 1;

        while( end &lt; s.length() ){
            String subString = s.substring(start, end);
            int indexOfChar = (int) (subString.indexOf(s.charAt(end)));
            if (indexOfChar &gt;= 0){
                start = start + indexOfChar + 1;
            }
            end++;
            max = max &lt; end - start ? end - start : max;
        }

        return max;
    }
}
</code></pre>
<h3 id="complexity-n-is-length-of-the-string"><a class="header" href="#complexity-n-is-length-of-the-string">Complexity (\(n\) is length of the string)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>Worst case: \( T(n) = \mathcal{\Theta}(n^2) \) 
<ul>
<li>String contains no repeating characters</li>
</ul>
</li>
<li>Average case: \( T(n) = O(n) \) 
<ul>
<li>(see <a href="medium-problems/3.html#average-time-complexity-for-the-algorithm">Further Discussion</a>)</li>
</ul>
</li>
<li>Best case: \( T(n) = \mathcal{\Theta}(n) \) 
<ul>
<li>String repeats same character</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(1) \)</li>
<li>Depends on implementation, Rust can achieve \( O(1) \)</li>
</ul>
<h2 id="further-discussion"><a class="header" href="#further-discussion">Further Discussion</a></h2>
<h3 id="average-time-complexity-for-the-algorithm"><a class="header" href="#average-time-complexity-for-the-algorithm">Average Time Complexity for the algorithm</a></h3>
<p><strong>Lemma: The algorithm run in \( O(n+X) \) where n is length of the string and X is number of comparison.</strong></p>
<p>Proof: We have n iterations and each iteration performs certain number of characters comparison to find first index of the same character.</p>
<p><strong>Theorem: The expected number of comparisons is \( O(n) \)</strong></p>
<p>Proof: </p>
<p>Assume \( M \) is the number of characters of the program choose to form a string and each character is equally likely to be chosen independently.</p>
<p>Let \( X_{ij} =  \unicode{x1D7D9}  \text{ { i-th character is compared to j-th character } }   \)</p>
<p>Consider a sequence of characters \( c_i c_{i+1} c_{i+2} ... c_{j-1} \) and a character \( c_j \) in a loop, \( c_i \) and \(c_j\) compares each other if-and-only-if the sequence of characters does not contains repeating characters. Otherwise the substring will be trimmed by our algorithm before the current loop.</p>
<p>For instance, consider a substring <code>abaabcd</code>, 1st <code>a</code> never compare with 2nd <code>b</code>, <code>c</code>, <code>d</code> since there are repeating characters between these pairs of characters (1st <code>a</code> and 2nd <code>b</code>, 1st <code>a</code> and <code>c</code>, 1st <code>a</code> and <code>d</code>).</p>
<p>The probability of \( c_i c_{i+1} c_{i+2} ... c_{j-1} \) does not contain repeating characters, according to formula of birthday paradox, is \(\frac{M!}{M^{(j-i)} (M - (j - i))! }\)</p>
<p>The total number of comparison \(\mathbb{E}[X] = \mathbb{E} \left [ \sum_{i = 0}^{n - 2} \sum_{j = i+1}^{n - 1} X_{ij} \right ] = \sum_{i = 0}^{n - 2} \sum_{j = i+1}^{n - 1} \mathbb{E}[ X_{ij}  ] \)</p>
<p>\(= \sum_{i = 0}^{n - 2} \sum_{j = i+1}^{n - 1} \frac{M!}{M^{(j-i)} (M - (j - i))! } \)</p>
<p>\(= \sum_{i = 0}^{n - 2} \sum_{ k = 1}^{n - 1 - i} \frac{M!}{M^{k} (M - k)! } \)</p>
<p>\( \le \sum_{i = 0}^{n - 2} \sum_{k = 1}^{M} \frac{M!}{M^{k} (M - k)! } \) </p>
<p>\(\because\) When  \(n \ge M \), the chance of substring without repeating characters becomes zero </p>
<p>\( \le \sum_{i = 0}^{n - 2} \int_{0}^{M} e^{ - x^2 / 2M } dx \) \( \ \because \) Approximation of the &quot;birthday formula&quot;</p>
<p>\( = \sum_{i = 0}^{n - 2} \frac{\sqrt{M\pi}}{\sqrt{2}} \ erf(\sqrt{\frac{M}{2}}) \)</p>
<p>\( \approx (n-1) 12.21 \) \( \ \because \) In ASCII table, dec32 to dec126 are charcters can be type in keyboard</p>
<p>\( = O(n) \)</p>
<p><strong>Interpretation</strong>: Seldom do two characters compare each other since when the distance between two characters becomes larger, the chance of the characters between them contains no repeating characters becomes smaller.</p>
<p><strong>Corollary: The average running time of the algorithm is \(O(n)\)</strong></p>
<p>Proof: Followed by the lemma and the theorem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-zigzag-conversion"><a class="header" href="#6-zigzag-conversion">6. Zigzag Conversion</a></h1>
<h2 id="description-of-the-problem-6"><a class="header" href="#description-of-the-problem-6">Description of the Problem</a></h2>
<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<pre><code class="language-P   A   H   N">A P L S I I G
Y   I   R
</code></pre>
<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<pre><code>string convert(string s, int numRows);
</code></pre>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3
Output: &quot;PAHNAPLSIIGYIR&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4
Output: &quot;PINALSIGYAHRPI&quot;

Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot;A&quot;, numRows = 1
Output: &quot;A&quot;
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> consists of English letters (lower-case and upper-case), <code>','</code> and <code>'.'</code>.</li>
<li><code>1 &lt;= numRows &lt;= 1000</code></li>
</ul>
<h2 id="solution-7"><a class="header" href="#solution-7">Solution</a></h2>
<h3 id="explanation-7"><a class="header" href="#explanation-7">Explanation</a></h3>
<p>The solution is less intutive. Consider the following example:
\[
\begin{matrix}
x_0 &amp;      &amp;     &amp;     &amp;     &amp; x_{10} &amp;        &amp;        &amp;         &amp;        &amp; x_{20} \\
x_1 &amp;      &amp;     &amp;     &amp; x_9 &amp; x_{11} &amp;        &amp;        &amp;         &amp; x_{19} &amp; x_{21} \\
x_2 &amp;      &amp;     &amp; x_8 &amp;     &amp; x_{12} &amp;        &amp;        &amp; x_{18}  &amp;        &amp; .      \\
x_3 &amp;      &amp; x_7 &amp;     &amp;     &amp; x_{13} &amp;        &amp; x_{17} &amp;         &amp;        &amp; .      \\
x_4 &amp;  x_6 &amp;     &amp;     &amp;     &amp; x_{14} &amp; x_{16} &amp;        &amp;         &amp;        &amp; .      \\
x_5 &amp;      &amp;     &amp;     &amp;     &amp; x_{15} &amp;        &amp;        &amp;         &amp;        &amp; .      \\
\end{matrix}
\]</p>
<p>Without consider extra characters of each row, the interval of index of two consecutive characters in a row is <code>2 * (num_rows - 1)</code> (e.g. <code>[x_0, x_10, x_20]</code> and <code>[x_1, x_11, x_21]</code>).</p>
<p>\[
\begin{matrix}
x_0 &amp;      &amp;     &amp;     &amp;     &amp; x_{10} &amp;     &amp;     &amp;      &amp;        &amp; x_{20} \\
x_1 &amp;      &amp;     &amp;     &amp; \_ &amp; x_{11} &amp;     &amp;     &amp;      &amp; \_    &amp; x_{21} \\
x_2 &amp;      &amp;     &amp; \_ &amp;     &amp; x_{12} &amp;     &amp;     &amp; \_  &amp;        &amp; .      \\
x_3 &amp;      &amp; \_ &amp;     &amp;     &amp; x_{13} &amp;     &amp; \_ &amp;      &amp;        &amp; .      \\
x_4 &amp;  \_ &amp;     &amp;     &amp;     &amp; x_{14} &amp; \_ &amp;     &amp;      &amp;        &amp; .      \\
x_5 &amp;      &amp;     &amp;     &amp;     &amp; x_{15} &amp;     &amp;     &amp;      &amp;        &amp; .      \\
\end{matrix}
\]</p>
<p>Then, consider the extra characters in the middle rows, the index of these characters are <code>(offset - r)</code> where <code>offset</code> is the interval multiplied by an integer k (i.e. <code>interval * k</code>), <code>r</code> is index of the row (i.e. <code>0</code> to <code>n-1</code>).</p>
<p>\[
\begin{matrix}
x_0 &amp;           &amp;          &amp;          &amp;          &amp; x_{10} &amp;          &amp;          &amp;          &amp;          &amp; x_{20} \\
x_1 &amp;           &amp;          &amp;          &amp; x_{10-1} &amp; x_{11} &amp;          &amp;          &amp;          &amp; x_{20-1} &amp; x_{21} \\
x_2 &amp;           &amp;          &amp; x_{10-2} &amp;          &amp; x_{12} &amp;          &amp;          &amp; x_{20-2} &amp;          &amp; .      \\
x_3 &amp;           &amp; x_{10-3} &amp;          &amp;          &amp; x_{13} &amp;          &amp; x_{20-3} &amp;          &amp;          &amp; .      \\
x_4 &amp;  x_{10-4} &amp;          &amp;          &amp;          &amp; x_{14} &amp; x_{20-4} &amp;          &amp;          &amp;          &amp; .      \\
x_5 &amp;           &amp;          &amp;          &amp;          &amp; x_{15} &amp;          &amp;          &amp;          &amp;          &amp; .      \\
\end{matrix}
\]</p>
<p>Now, the solution is to append characters according to row number and index.</p>
<h3 id="code-rust-5"><a class="header" href="#code-rust-5">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn convert(s: String, num_rows: i32) -&gt; String {

        let num_rows = num_rows as usize;
        let n = s.len();

        if num_rows == 1 {
            return s;
        }

        let mut result = vec![];
        let char_array = s.as_bytes();

        for r in 0..num_rows {
            let mut offset = 0;
            while r + offset &lt; n {
                result.push(char_array[r+offset]);
                offset += 2*(num_rows - 1);
                if 1 &lt;= r &amp;&amp; r &lt;= num_rows - 2 &amp;&amp; offset &lt; n + r {
                    result.push(char_array[offset-r]);
                }
            }
        }

        return String::from_utf8(result).unwrap();
    }
}
</code></pre>
<h3 id="complexity-n-is-the-length-of-string-s"><a class="header" href="#complexity-n-is-the-length-of-string-s">Complexity (n is the length of string s)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\(O(n)\)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(n) \)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-reverse-integer"><a class="header" href="#7-reverse-integer">7. Reverse Integer</a></h1>
<h2 id="description-of-the-problem-7"><a class="header" href="#description-of-the-problem-7">Description of the Problem</a></h2>
<p>Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range <code>[-2^31, 2^31 - 1]</code>, then return <code>0</code>.</p>
<p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: x = 123
Output: 321
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: x = -123
Output: -321
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: x = 120
Output: 21
</code></pre>
<p><strong>Constraints:</strong>
<code>-2^31 &lt;= x &lt;= 2^31 - 1</code></p>
<h2 id="solution-8"><a class="header" href="#solution-8">Solution</a></h2>
<h3 id="explanation-8"><a class="header" href="#explanation-8">Explanation</a></h3>
<p>Method 1: Use standard library to convert integer</p>
<p>Method 2: Do the Method by yourself. First perform checking of overflow/underflow. Then reverse the integer.</p>
<p><strong>Checking of Overflow/Underflow</strong></p>
<p>If a reverse integer overflows (or underflows), then it has at least 10 digits. (Since <code>i32::MAX</code> and <code>i32::MIN</code> has 10 digits). By contraposition, any number has less than 10 digits does not overflows (nor underflows).</p>
<p>To check whether a reversed full-digit integer overflows (or underflows), we can compare the number with <code>i32::MAX</code> or <code>i32::MIN</code> digit-by-digit. </p>
<p>Example 1: reverse of <code>2091748912</code> is <code>2198471902</code>. Compare the reversed with <code>i32::MAX</code> digit-by-digit</p>
<pre><code>2198471902
2147483647
-----------
1st digit: they are equal (i.e. 2) ==&gt; compare next digit
2nd digit: they are equal (i.e. 1) ==&gt; compare next digit
3nd digit: 9 &gt; 4 ==&gt; It overflows
</code></pre>
<p>Example 2: reverse of <code>2091748012</code> is <code>2108471902</code>. Compare the reversed with <code>i32::MAX</code> digit-by-digit</p>
<pre><code>2108471902
2147483647
-----------
1st digit: they are equal (i.e. 2) ==&gt; compare next digit
2nd digit: they are equal (i.e. 1) ==&gt; compare next digit
3nd digit: 0 &lt; 4 ==&gt; It is not possible to overflow
</code></pre>
<p>After the checking, just simply calculate the reversed value.</p>
<h3 id="code---method-1-rust"><a class="header" href="#code---method-1-rust">Code - Method 1 (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn reverse(n: i32) -&gt; i32 {
        let result = 
        if n &gt; 0 {
            n.to_string() // convert the number into String
            .chars().rev() // reverse the number_string
            .collect::&lt;String&gt;() 
            .parse::&lt;i32&gt;() // try to parse the reversed number_string
        }
        else{
            n.to_string() // convert the number into String
            .chars().skip(1) // skip 1st character i.e. minus sign
            .collect::&lt;String&gt;() // convert it into String due to its type
            .chars().rev() // reverse the number_string
            .collect::&lt;String&gt;()
            .parse::&lt;i32&gt;() // try to parse the reversed number_string
            .map(|x| -x)
        };

        // Unwrap the result
        return if let Ok(x) = result{
            x
        }
        else{
            0
        };
    }
}
</code></pre>
<h3 id="code---method-2-rust"><a class="header" href="#code---method-2-rust">Code - Method 2 (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {

    pub fn reverse(n: i32) -&gt; i32 {
        static MAX_POW : u32 = 9; // std::i32::MAX and std::i32::MIN has 10 digits
        static TEN : i32 = 10;
        if Solution::will_overflow_or_underflow(n){
            return 0;
        }

        // Calculate the sum
        let mut sum = 0;
        let mut n = n;
        while n != 0 {
            sum *= 10;
            sum += n % 10;
            n /= 10;
        }

        return sum;
    }

    fn will_overflow_or_underflow(n : i32) -&gt; bool {
        static MAX_POW : u32 = 9;
        static TEN : i32 = 10;

        // if the number is not in full-digit, so is its reverse
        if ( n&gt;= 0 &amp;&amp; n &lt; TEN.pow(MAX_POW)) || (n &lt; 0 &amp;&amp; n &gt; -TEN.pow(MAX_POW)){
            return false;
        }

        // Otherwise, check whether the reverse will overflow
        let mut is_not_overflow = true;
        let mut is_continued;
        for p in 0..=MAX_POW{
            let digit_n = n / TEN.pow(p) % 10;
            if n &gt;= 0{
                let digit_max = std::i32::MAX / TEN.pow(MAX_POW - p) % 10;
                is_not_overflow = digit_n &lt;= digit_max;
                // If the digits are equal, then we have to check next digits
                // Otherwise, its reverse must be smaller than std::i32::MAX
                is_continued = is_not_overflow &amp;&amp; digit_n == digit_max;
            }else{
                let digit_min = std::i32::MIN / TEN.pow(MAX_POW - p) % 10;
                is_not_overflow = digit_n &gt;= digit_min;
                // Similarly, if the digits are equal, then we have to check next digits
                // Otherwise, its reverse must be smaller than std::i32::MIN
                is_continued = is_not_overflow &amp;&amp; digit_n == digit_min;
            }

            if !is_continued{break;}
        }
        return !is_not_overflow;
    }
}
</code></pre>
<h3 id="complexity---method-2-d-is-the-number-of-digits"><a class="header" href="#complexity---method-2-d-is-the-number-of-digits">Complexity - Method 2 (\(d\) is the number of digits)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\( T(n) = O(2d) \)
<ul>
<li>Perform Overflow/Underflow checking and Calculate the reversed number</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(1) \)
<ul>
<li>Extracted digits are stored in local variables</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-letter-combination-of-a-phone-number"><a class="header" href="#17-letter-combination-of-a-phone-number">17. Letter Combination of a Phone Number</a></h1>
<h2 id="description-of-the-problem-8"><a class="header" href="#description-of-the-problem-8">Description of the Problem</a></h2>
<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>
<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: digits = &quot;23&quot;
Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: digits = &quot;&quot;
Output: []
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: digits = &quot;2&quot;
Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> is a digit in the range <code>['2', '9']</code>.</li>
</ul>
<h2 id="solution-9"><a class="header" href="#solution-9">Solution</a></h2>
<h3 id="explanation-9"><a class="header" href="#explanation-9">Explanation</a></h3>
<p>The core of the solution is to define a function to do Cartesian product for list of string. It can be easily implemented by an nested loop.</p>
<h3 id="code-rust-6"><a class="header" href="#code-rust-6">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn letter_combinations(digits: String) -&gt; Vec&lt;String&gt; {
        // m a -&gt; (a -&gt; m b) -&gt; m b
        let product = | v1: &amp;Vec&lt;String&gt;, v2 : &amp;Vec&lt;&amp;str&gt; | -&gt; Vec&lt;String&gt; {
            v1.iter().map(
                |e1| v2.iter().map(
                    |e2| format!(&quot;{}{}&quot;, e1, e2)
                ).collect::&lt;Vec&lt;String&gt;&gt;()
            )
            .flatten().collect::&lt;Vec&lt;String&gt;&gt;()
        };

        let mut result : Vec&lt;String&gt; = vec![];

        for c in digits.chars() {
            let rhs = match c {
                '2' =&gt; vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],
                '3' =&gt; vec![&quot;d&quot;, &quot;e&quot;, &quot;f&quot;],
                '4' =&gt; vec![&quot;g&quot;, &quot;h&quot;, &quot;i&quot;],
                '5' =&gt; vec![&quot;j&quot;, &quot;k&quot;, &quot;l&quot;],
                '6' =&gt; vec![&quot;m&quot;, &quot;n&quot;, &quot;o&quot;],
                '7' =&gt; vec![&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;],
                '8' =&gt; vec![&quot;t&quot;, &quot;u&quot;, &quot;v&quot;],
                '9' =&gt; vec![&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;],
                _ =&gt; panic!(&quot;Impossible&quot;),
            };

            result = 
                if result.len() == 0 { product(&amp;vec![&quot;&quot;.to_string()], &amp;rhs) } 
                else { product(&amp;result, &amp;rhs) };
        }

        return result;
    }
}
</code></pre>
<h3 id="code-java-4"><a class="header" href="#code-java-4">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public List&lt;String&gt; letterCombinations(String digits) {
        if ( digits.equals(&quot;&quot;) )
            return Collections.emptyList();
        
        List&lt;String&gt; result = List.of(&quot;&quot;);

        for (char d : digits.toCharArray()){
            switch(d){
                case '2':
                    result = product(result, List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
                    break;
                case '3':
                    result = product(result, List.of(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;));
                    break;
                case '4':
                    result = product(result, List.of(&quot;g&quot;, &quot;h&quot;, &quot;i&quot;));
                    break;
                case '5':
                    result = product(result, List.of(&quot;j&quot;, &quot;k&quot;, &quot;l&quot;));
                    break;
                case '6':
                    result = product(result, List.of(&quot;m&quot;, &quot;n&quot;, &quot;o&quot;));
                    break;
                case '7':
                    result = product(result, List.of(&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;));
                    break;
                case '8':
                    result = product(result, List.of(&quot;t&quot;, &quot;u&quot;, &quot;v&quot;));
                    break;
                case '9':
                    result = product(result, List.of(&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
                    break;
            }
        }

        return result;

    }

    List&lt;String&gt; product(List&lt;String&gt; list1, List&lt;String&gt; list2){
        List&lt;String&gt; list3 = new ArrayList&lt;&gt;();
        for(String s1 : list1){
            for(String s2 : list2){
                list3.add(s1+s2);
            }
        }
        return list3;
    }
}
</code></pre>
<h3 id="complexity-d-is-the-length-of-the-digits"><a class="header" href="#complexity-d-is-the-length-of-the-digits">Complexity (d is the length of the digits)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\(O(4^d)\)
<ul>
<li>Each product need <code>len(L_1) * len(L_2)</code></li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(1) \)
<ul>
<li>The old <code>List&lt;&gt;</code>/<code>Vec&lt;&gt;</code> is discard in memory by &quot;RAII&quot; if it is not in used.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24-swap-nodes-in-pairs"><a class="header" href="#24-swap-nodes-in-pairs">24. Swap Nodes in Pairs</a></h1>
<h2 id="description-of-the-problem-9"><a class="header" href="#description-of-the-problem-9">Description of the Problem</a></h2>
<p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,2,3,4]
Output: [2,1,4,3]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = []
Output: []
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: head = [1]
Output: [1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is in the range <code>[0, 100]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="solution-10"><a class="header" href="#solution-10">Solution</a></h2>
<h3 id="explanation-10"><a class="header" href="#explanation-10">Explanation</a></h3>
<p>As illustrated below (in Haskell), swapping first two nodes and recursively call the function on remaining nodes again.</p>
<pre><code class="language-Haskell">swapNodesInPair :: [a] -&gt; [a]
swapNodesInPair [] = []
swapNodesInPair [x] = [x]
swapNodesInPair (x1:x2:xs) = x2:x1:(swapNodesInPair xs)
</code></pre>
<h3 id="code-rust-7"><a class="header" href="#code-rust-7">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -&gt; Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn swap_pairs(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        match head{
            None =&gt; return None,

            // Move value as mutable
            Some(mut p) =&gt; {
                match p.next {
                    None =&gt; Some(p),
                    Some(mut q) =&gt; {
                        let rest = Self::swap_pairs(q.next);
                        p.next = rest;
                        q.next = Some(p);
                        return Some(q);
                    }
                }
            }
        }        
    }
}
</code></pre>
<h3 id="code-java-5"><a class="header" href="#code-java-5">Code (Java)</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null){return null;}
        if (head.next == null) {return head;}

        ListNode temp = head.next.next;
        head.next.next = head;
        head = head.next;
        head.next.next = swapPairs(temp);
        return head;
    }
}
</code></pre>
<h3 id="complexity-n-is-the-number-of-nodes-in-a-linked-list"><a class="header" href="#complexity-n-is-the-number-of-nodes-in-a-linked-list">Complexity (n is the number of nodes in a linked list)</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( O(n) \)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(n) \)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="50-powx-n"><a class="header" href="#50-powx-n">50. Pow(x, n)</a></h1>
<h2 id="description-of-problem-1"><a class="header" href="#description-of-problem-1">Description of Problem</a></h2>
<p>Implement pow(x, n), which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x^n</code>).</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: x = 2.00000, n = 10
Output: 1024.00000
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: x = 2.10000, n = 3
Output: 9.26100
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25 
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>-100.0 &lt; x &lt; 100.0</code></li>
<li><code>-2^31 &lt;= n &lt;= 2^31-1</code></li>
<li><code>n</code> is an integer.</li>
<li>Either <code>x</code> is not zero or <code>n &gt; 0.</code></li>
<li><code>-10^4</code> &lt;= <code>x^n</code> &lt;= <code>10^4</code></li>
</ul>
<h2 id="solution-11"><a class="header" href="#solution-11">Solution</a></h2>
<h3 id="explantion"><a class="header" href="#explantion">Explantion</a></h3>
<p>The core of the problem is to consider all edge cases and remember to handle the overflow/underflow cases. The calculation can be done by &quot;Divide and Conquer&quot; approach.</p>
<h3 id="code-rust-8"><a class="header" href="#code-rust-8">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    fn my_pow(x : f64, n: i32) -&gt; f64{
        match (x, n){
            (0.0, _) =&gt; 0.0,
            (-1.0, n) =&gt; if n % 2 == 1 {-1.0} else {1.0},
            (1.0, _) | (_, 0) =&gt; 1.0,
            (x, i32::MIN) =&gt; 1.0 / Self::my_pow(x, -(n+1)),
            (x, n) =&gt; {
                if n &lt; 0 {
                    1.0 / Self::my_pow(x, -n)
                }
                else{
                    let v = Self::my_pow(x, n/2);
                    match (n % 2 == 0) {
                        true =&gt; v * v,
                        false =&gt; v * v * x,
                    }
                }
            }
        }
    }

}
</code></pre>
<h3 id="complexity-n-is-the-exponent"><a class="header" href="#complexity-n-is-the-exponent">Complexity (n is the exponent)</a></h3>
<p>Time complexity:</p>
<ul>
<li>\(T(n)=O(\log(n))\)
<ul>
<li>In general, the number of functional calls is bound by \(\log(n)\).</li>
</ul>
</li>
</ul>
<p>Auxiliary Space:</p>
<ul>
<li>\(S(n)=O(\log(n))\)
<ul>
<li>Same reason as the above-mentioned.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="55-jump-game"><a class="header" href="#55-jump-game">55. Jump Game</a></h1>
<h2 id="description-of-problem-2"><a class="header" href="#description-of-problem-2">Description of Problem</a></h2>
<p>You are given an integer array <code>nums</code>. You are initially positioned at the array's <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p>
<p>Return <code>true</code> <em>if you can reach the last index</em>, or <code>false</code> otherwise.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<h2 id="solution-12"><a class="header" href="#solution-12">Solution</a></h2>
<h3 id="explantion-1"><a class="header" href="#explantion-1">Explantion</a></h3>
<p>The core concept is to record the current maximum reachable distance. For each node, if the node is currently reachable, then <strong>update the current maximum reachable distance</strong>. Otherwise, the final node is unreachable.</p>
<h3 id="code-java-6"><a class="header" href="#code-java-6">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public boolean canJump(int[] nums) {
        int reachable = 0;
        int n = nums.length;
        for(int i = 0; i &lt; n; i++){
            if (reachable &lt; i){
                return false;
            }
            reachable = Math.max(reachable, i + nums[i]);
            if (reachable &gt;= n-1){
                return true;
            }
        }
        return true;
    }
}
</code></pre>
<h3 id="complexity-5"><a class="header" href="#complexity-5">Complexity</a></h3>
<p>Time complexity:</p>
<ul>
<li>\(T(n)=O(n)\)</li>
</ul>
<p>Auxiliary Space:</p>
<ul>
<li>\(S(n)=O(1)\)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="78-subsets"><a class="header" href="#78-subsets">78. Subsets</a></h1>
<h2 id="description-of-the-problem-10"><a class="header" href="#description-of-the-problem-10">Description of the Problem</a></h2>
<p>Given an integer array <code>nums</code> of unique elements, return all possible subsets (the power set).</p>
<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [0]
Output: [[],[0]]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li>All the numbers of nums are unique.</li>
</ul>
<h2 id="solution-13"><a class="header" href="#solution-13">Solution</a></h2>
<h3 id="explanation-11"><a class="header" href="#explanation-11">Explanation</a></h3>
<p>For any elements in a set, we have two options (Yes-No Question Method): either it is in the subset and it isn't in the subset.</p>
<h3 id="code-rust-9"><a class="header" href="#code-rust-9">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {

    fn helper_subset(mut xs: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt;{
        if xs.len() == 0 {
            return vec![vec![]];
        }

        let lst = xs.pop().unwrap();

        // The left solution contains subset which `lst` isn't the member of these subsets
        let mut left = Solution::helper_subset(xs.clone());

        // The solution contains subsets which `lst` is the member of these subsets
        let mut right = Solution::helper_subset(xs);
        for s in right.iter_mut(){
            (*s).push(lst);
        }

        for s in right.into_iter(){
            left.push(s);
        }

        return left;
    }

    pub fn subsets(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        return Solution::helper_subset(nums);
    }
}
</code></pre>
<h3 id="complexity-n-is-the-number-of-elements-in-the-set"><a class="header" href="#complexity-n-is-the-number-of-elements-in-the-set">Complexity (n is the number of elements in the set)</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( \Theta(2^n) \)
<ul>
<li>Recursive Approach: \(T(n) = 2 \cdot T(n - 1)\)</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(2^n) \)
<ul>
<li>Stores \(2^n\) elements</li>
<li>\(n\) for stack calls</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="98-validate-binary-search-tree"><a class="header" href="#98-validate-binary-search-tree">98. Validate Binary Search Tree</a></h1>
<h2 id="description-of-the-problem-11"><a class="header" href="#description-of-the-problem-11">Description of the Problem</a></h2>
<p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node's key.
The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node's key.
Both the left and right subtrees must also be binary search trees.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [2,1,3]
Output: true
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 10^4]</code>.</li>
<li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li>
</ul>
<h2 id="solution-14"><a class="header" href="#solution-14">Solution</a></h2>
<h3 id="explanation-12"><a class="header" href="#explanation-12">Explanation</a></h3>
<p>The problem itself explains how to form a solution.</p>
<pre><code>The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
</code></pre>
<p>To check the above properies, each parent node must know the in-order traversal of both sub-trees. When in-order traversals are available, they can be compared with the parent value.</p>
<p>To speed up the evaluation of the properties, the recursive function return <code>true</code> when the properties are matched, otherwise it return <code>false</code>. If parent node receives <code>false</code> from a child, the function skips the comparsion (Reminder: The order of boolean expressions matters). </p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<pre><code class="language-Rust">use std::rc::Rc;
use std::cell::RefCell;
impl Solution{
    pub fn is_valid_bst(root : Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {
        let (is_valid, _) = Solution::verify(root);
        return is_valid;
    }

    fn verify(node : Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; (bool, Vec&lt;i32&gt;){
        if let Some(node) = node {
            let node = node.borrow();
            let (is_left_valid, mut left_vec) = Solution::verify(node.left.clone());
            let (is_right_valid, right_vec) = Solution::verify(node.right.clone());
            let is_this_valid = is_left_valid &amp;&amp; is_right_valid 
                &amp;&amp; left_vec.iter().all( |l| *l &lt; node.val )
                &amp;&amp; right_vec.iter().all( |r| node.val &lt; *r );
            left_vec.push(node.val);
            left_vec.extend(right_vec);
            return (is_this_valid, left_vec);
        }

        return (true, vec![]);
    }
}
</code></pre>
<h3 id="complexity-n-is-the-number-of-node-and-h-is-height-of-tree"><a class="header" href="#complexity-n-is-the-number-of-node-and-h-is-height-of-tree">Complexity (n is the number of node and h is height of tree)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>Worst case: \(O(n^2)\)
<ul>
<li>Recursive formula: \( T(n) = T(n-1) + T(1) + cn \)</li>
</ul>
</li>
<li>For balance tree: \(O(n \log n)\)
<ul>
<li>Recursive formula: \( T(n) = 2 \ T(n/2) + cn \)</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(n) \)
<ul>
<li>The size of call stack and list of number are bound by height of the tree and the number of nodes. Also, the height cannot exceed the number of tree nodes.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="113-path-sum-ii"><a class="header" href="#113-path-sum-ii">113. Path Sum II</a></h1>
<h2 id="description-of-the-problem-12"><a class="header" href="#description-of-the-problem-12">Description of the Problem</a></h2>
<p>Given the root of a binary tree and an integer <code>targetSum</code>, return all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node <strong>values</strong>, not node references.</p>
<p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: [[5,4,11,2],[5,8,4,5]]
Explanation: There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = [1,2,3], targetSum = 5
Output: []
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: root = [1,2], targetSum = 0
Output: []
</code></pre>
<p><strong>Constraints:</strong>
The number of nodes in the tree is in the range <code>[0, 5000]</code>.</p>
<ul>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="solution-15"><a class="header" href="#solution-15">Solution</a></h2>
<h3 id="explanation-13"><a class="header" href="#explanation-13">Explanation</a></h3>
<p>The following code explains itself.</p>
<h3 id="coderust"><a class="header" href="#coderust">Code(Rust)</a></h3>
<pre><code class="language-Rust">use std::rc::Rc;
use std::cell::RefCell;

impl Solution {
    pub fn path_sum(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, target_sum: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        let mut answer = Vec::new();
        Self::dfs(root, target_sum, &amp;mut Vec::new(), &amp;mut answer);
        answer
    }
    fn dfs(
        node: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
        target_sum: i32,
        v: &amp;mut Vec&lt;i32&gt;,
        answer: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;,
    ) {
        if let Some(n) = node {
            let val = n.borrow().val;
            let l = n.borrow().left.clone();
            let r = n.borrow().right.clone();
            v.push(val);
            if target_sum == val &amp;&amp; l.is_none() &amp;&amp; r.is_none() {
                answer.push(v.clone());
            }
            Self::dfs(l, target_sum - val, v, answer);
            Self::dfs(r, target_sum - val, v, answer);
            v.pop();
        }
    }
}
</code></pre>
<h3 id="complexity-n-is-the-number-of-node-and-h-is-height-of-tree-1"><a class="header" href="#complexity-n-is-the-number-of-node-and-h-is-height-of-tree-1">Complexity (n is the number of node and h is height of tree)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>Worst case: \(\Theta(n)\)
<ul>
<li>Traverse all nodes</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(h) \)
<ul>
<li>The size of temp array and call stack are bound by the height of the tree</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="143-reorder-list"><a class="header" href="#143-reorder-list">143. Reorder List</a></h1>
<h2 id="description-of-problem-3"><a class="header" href="#description-of-problem-3">Description of Problem</a></h2>
<p>You are given the head of a singly linked-list. The list can be represented as:
<code>L0 → L1 → … → Ln - 1 → Ln</code></p>
<p>Reorder <em>the list to be on the following form</em>:
<code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code>
You may not modify the values in the list's nodes. Only nodes themselves may be changed.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,2,3,4]
Output: [1,4,2,3]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is in the range <code>[1, 5 * 10^4]</code>.</li>
<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="solution-16"><a class="header" href="#solution-16">Solution</a></h2>
<h3 id="explanation-14"><a class="header" href="#explanation-14">Explanation</a></h3>
<p>Simply speaking, find the middle node using fast and slow pointers, cut the list into two lists, reverse the latter and combine them.</p>
<h3 id="code-c-2"><a class="header" href="#code-c-2">Code (C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    
public:
    void reorderList(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;

        // 1. Find the middle node
        while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr){
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }

        // 2. Cut and Reverse
        ListNode* curr = slow-&gt;next; 
        ListNode* prev = nullptr;
        slow-&gt;next = nullptr; // Cut

        // Reverse
        while(curr != nullptr){
            ListNode* temp = curr;
            curr = temp-&gt;next;
            temp-&gt;next = prev;
            prev = temp;
        }

        // 3. Merge
        ListNode* list1 = head; ListNode* list2 = prev;
        while(list1 != nullptr &amp;&amp; list2 != nullptr){
            ListNode* temp1 = list1-&gt;next;
            ListNode* temp2 = list2-&gt;next;
            list1-&gt;next = list2;
            list2-&gt;next = temp1;
            list1 = temp1;
            list2 = temp2;
        }


    }
};
</code></pre>
<h3 id="complexity-6"><a class="header" href="#complexity-6">Complexity</a></h3>
<p>Time complexity:</p>
<ul>
<li>\(T(n)=O(n)\)
<ul>
<li>There are only nearly constant number of n iterations</li>
</ul>
</li>
</ul>
<p>Auxiliary Space:</p>
<ul>
<li>\(S(n)=O(1)\)
<ul>
<li>Use only constant number of variables</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="150-evaluate-reverse-polish-notation"><a class="header" href="#150-evaluate-reverse-polish-notation">150. Evaluate Reverse Polish Notation</a></h1>
<h2 id="description-of-the-problem-13"><a class="header" href="#description-of-the-problem-13">Description of the Problem</a></h2>
<p>You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.</p>
<p>Evaluate the expression. Return an integer that represents the value of the expression.</p>
<p>Note that:</p>
<ul>
<li>The valid operators are <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, and <code>'/'</code>.</li>
<li>Each operand may be an integer or another expression.</li>
<li>The division between two integers always <strong>truncates toward zero</strong>.</li>
<li>There will not be any division by zero.</li>
<li>The input represents a valid arithmetic expression in a reverse polish notation.</li>
<li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]
Output: 9
Explanation: ((2 + 1) * 3) = 9
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]
Output: 6
Explanation: (4 + (13 / 5)) = 6
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 10^4</code></li>
<li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li>
</ul>
<h2 id="solution-17"><a class="header" href="#solution-17">Solution</a></h2>
<h3 id="explanation-15"><a class="header" href="#explanation-15">Explanation</a></h3>
<p>Simply speaking, when the token is an number, push into the stack; when the token is an operator, pop two numbers and calculate the result, push the result back to the stack.</p>
<h3 id="code-rust-10"><a class="header" href="#code-rust-10">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn eval_rpn(tokens: Vec&lt;String&gt;) -&gt; i32 {
        let mut stack = vec![];
        for token in tokens {
            match(token.as_str()){
                &quot;+&quot; =&gt; {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    stack.push(a + b);
                },
                &quot;-&quot; =&gt; {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    stack.push(a - b);
                },
                &quot;*&quot; =&gt; {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    stack.push(a * b);
                },
                &quot;/&quot; =&gt; {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    stack.push(a / b);
                },
                _ =&gt; {
                    stack.push(token.parse::&lt;i32&gt;().unwrap());
                },
            }
        }

        if stack.len() != 1{
            panic!(&quot;Invalid Token&quot;);
        }else{
            return stack.pop().unwrap();
        }

    }
}
</code></pre>
<h3 id="complexity-n-is-the-number-of-tokens"><a class="header" href="#complexity-n-is-the-number-of-tokens">Complexity (n is the number of tokens)</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( O(n) \)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(n) \)
<ul>
<li>The size of the stack is bound by number of tokens</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="151-reverse-words-in-a-string"><a class="header" href="#151-reverse-words-in-a-string">151. Reverse Words in a String</a></h1>
<h2 id="description-of-the-problem-14"><a class="header" href="#description-of-the-problem-14">Description of the Problem</a></h2>
<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>
<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in s will be separated by at least one space.</p>
<p>Return <em>a string of the words in reverse order concatenated by a single space</em>.</p>
<p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;the sky is blue&quot;
Output: &quot;blue is sky the&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;  hello world  &quot;
Output: &quot;world hello&quot;
Explanation: Your reversed string should not contain leading or trailing spaces.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot;a good   example&quot;
Output: &quot;example good a&quot;
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces ' '.</li>
<li>There is at least one word in <code>s</code>.</li>
</ul>
<p>Follow-up: If the string data type is mutable in your language, can you solve it in-place with <code>O(1)</code> extra space?</p>
<h2 id="solution-18"><a class="header" href="#solution-18">Solution</a></h2>
<h3 id="explanation-16"><a class="header" href="#explanation-16">Explanation</a></h3>
<p>Simple Idea:</p>
<ul>
<li>To reverse each word in a string, do mirroring to each word and then do mirroring to the whole string.</li>
<li>To do mirroring for each word, we have to scan each word (using sliding windows, i.e. tokenise)</li>
<li>The follow-up question requires us to do almost any operations in-place. We can first copy each token to suitable place by sliding windows method. For example, <code>____ABC</code> becomes <code>ABC_ABC</code>.</li>
</ul>
<p>Reminder:</p>
<ul>
<li>(*) To fullfill the follow-up question, do not create too much copy of the <code>String</code>. Keep in mind that even if some methods/functions do not have <code>new</code> keyword, the code behind these methods/functions may contain <code>new</code> keyword in their implementation (i.e. they use extra space). For example, in Java, <code>.substring(i, j)</code> will create new <code>String</code> in Heap. To know more about this, please look at the source code. 
<ul>
<li>Rust provides source code in their offcial website. </li>
<li>You can also look at the source code of Java via IDE.</li>
</ul>
</li>
<li>In my opinion, the key idea of the problems is to illistrate you are able to acheive \( O(1) \) conceptually. It is not necessary to implement it so carefully.</li>
</ul>
<p><strong>My definition to &quot;extra/auxiliary space&quot; is excluding input space and output space</strong></p>
<h3 id="code-rust-11"><a class="header" href="#code-rust-11">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn reverse_words(s: String) -&gt; String {
        let space_in_u8 = 32;

        // According to RustDoc: &quot;This consumes the `String`, so we do not need to copy its contents&quot;
        // i.e. convert it into Vec&lt;u8&gt; costs O(1) Space
        let mut v = s.into_bytes();

        // i, j for sliding window,
        // k is location of cell to be filled-in
        let (mut i, mut j, mut k, n) = (0,0,0,v.len());
        while j &lt; n {
            match (v[i] == space_in_u8, v[j]==space_in_u8){

                // Case 1: Sliding window contains only space, move two pointers
                (true, true) =&gt; {i+=1; j+=1;},

                // Impossible case
                (true, false) =&gt; {panic!(&quot;Reaches impossible case&quot;);},

                // Case 2: sliding window complete the scanning of a word
                (false, true) =&gt; {

                    // If the &quot;current result&quot; has some word, append space
                    if k &gt; 0 {
                        v[k] = space_in_u8;
                        k+=1;
                    }

                    // v[k..k+j-i] = v[i..j].reverse()
                    Solution::copy_and_reverse(&amp;mut v, i, j, &amp;mut k);

                    // reset pointer location by right j by 1, i points to where j locates
                    j+=1;
                    i=j;
                },

                // Case 3: Sliding window contains only characters
                // It may not complete the scanning
                (false, false) =&gt; {
                    j+=1;
                    // If j reaches the end of string, do copy_and_reverse
                    if j == n {
                        if k &gt; 0 {
                            v[k] = space_in_u8;
                            k+=1;
                        }
                        Solution::copy_and_reverse(&amp;mut v, i, j, &amp;mut k);
                    }
                }

            }
        }

        v.truncate(k); // cut unnecessary characters 
        Solution::reverse_string(&amp;mut v, 0, k); // reverse the whole string

        // Convert Vec&lt;u8&gt; back to String
        // It costs O(1) according to String implmentation (see source code of Rust)
        // i.e. give ownership of Vec&lt;u8&gt; to String Struct
        return unsafe { String::from_utf8_unchecked(v) }; 
    }

    // v[k..k+j-i] = v=[i..j].reverse()
    fn copy_and_reverse(v: &amp;mut Vec&lt;u8&gt;, begin: usize, end: usize, k: &amp;mut usize){
        let k_origin = *k;

        // v[k..k+j-i] = v=[i..j]
        for i in (begin..end){
            v[*k] = v[i];
            *k +=1;
        }

        Solution::reverse_string(v, k_origin, k_origin+end-begin);
    }

    // v[k..k+j-i].reverse()
    fn reverse_string(v: &amp;mut Vec&lt;u8&gt;, begin: usize, end: usize){
        let (mut i, mut j) = (begin, end - 1);
        while i &lt; j {
            let tmp = v[i];
            v[i] = v[j];
            v[j] = tmp;
            i+=1;
            j-=1;
        }
    }
}
</code></pre>
<h3 id="complexity-n-is-length-of-the-string-1"><a class="header" href="#complexity-n-is-length-of-the-string-1">Complexity (\(n\) is length of the string)</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( O(2n) \)
<ul>
<li>Mirroring the whole string cost \( n / 2 \)</li>
<li>Copying and mirroring a token cost \( m + m / 2 \) where m is the length of token. Since sum of the length of tokens does not exceed \(n\). The total cost less than \( 3n/2 \)</li>
<li>The combined complexity is \( O(2n) \)</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(1) \)
<ul>
<li>Depends on Programming Language and implementation</li>
<li>Conceptually it can acheive O(1) Space</li>
</ul>
</li>
</ul>
<h2 id="further-discussion-1"><a class="header" href="#further-discussion-1">Further Discussion</a></h2>
<h3 id="limitation-of-a-programming-language-and-turing-equivalence"><a class="header" href="#limitation-of-a-programming-language-and-turing-equivalence">Limitation of a Programming Language and Turing Equivalence(?)</a></h3>
<p>Some people argue that each language has its limitation. For instance, Java cannot actually acheive \(O(1)\) extra space in this problem. </p>
<p>To some extent, I will agree. Theoretically, however, if each programming language simluates <strong>Universal Turing Machine</strong>, they should be equivalent. This implies that there is no operation Rust can do but Java can't. The only matter is the cost for one language to simulate another. Just like to simulates Two-Tape Turing Machine by the One-Tape, we need more steps/operations in One-Tape Turing Machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="179-largest-number"><a class="header" href="#179-largest-number">179. Largest Number</a></h1>
<h2 id="description-of-the-problem-15"><a class="header" href="#description-of-the-problem-15">Description of the Problem</a></h2>
<p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p>
<p>Since the result may be very large, so you need to return a string instead of an integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [10,2]
Output: &quot;210&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [3,30,34,5,9]
Output: &quot;9534330&quot;
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 100</li>
<li>0 &lt;= nums[i] &lt;= 10^9</li>
</ul>
<h2 id="solution-19"><a class="header" href="#solution-19">Solution</a></h2>
<h3 id="explanation-17"><a class="header" href="#explanation-17">Explanation</a></h3>
<h4 id="greediness-of-the-problem"><a class="header" href="#greediness-of-the-problem">Greediness of the Problem</a></h4>
<h5 id="greedy-choice-properties"><a class="header" href="#greedy-choice-properties">Greedy-choice Properties</a></h5>
<p>To acheive the largest number, we have to choose the most signficant digits that make the whole number largest. And</p>
<p>to choose the most signficant digits, simply pick the number in <code>nums</code> such that their &quot;concatenation&quot; is the largest. </p>
<p>For example, in <code>[3,30,34,5,9]</code>, <code>9</code> is the suitable choice because: </p>
<ul>
<li>9 3 _ &gt; 3 9 _</li>
<li>9 3 0 &gt; 3 0 9 </li>
<li>9 3 4 &gt; 3 4 9 </li>
<li>9 5 _ &gt; 5 9 _</li>
</ul>
<p>i.e. If <code>9</code> is in position of the most signficant digits, the whole number is the largest.</p>
<p>Thus, before choosing numbers, we can sort the <code>nums</code> by their &quot;concatenation value&quot; in descending order.</p>
<h5 id="optimal-substructure-properties"><a class="header" href="#optimal-substructure-properties">Optimal Substructure Properties</a></h5>
<p>After choosing the most signficant digits, the remaining problem is to find most signficant digits for remaining positions of the whole number.</p>
<h3 id="code-rust-12"><a class="header" href="#code-rust-12">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn largest_number(mut nums: Vec&lt;i32&gt;) -&gt; String {
        nums
        .sort_by(
            |a,b| format!(&quot;{}&quot;, b)
            .cmp(
                &amp;format!(&quot;{}&quot;, a)
            )
        );
        
        nums.into_iter()
        .fold( 
            String::from(&quot;&quot;),
            |mut acc, x| 
                if acc == &quot;0&quot;  { 
                    x.to_string() 
                } 
                else { 
                    acc.push_str(&amp;x.to_string()); 
                    acc 
                }
        )
    }
}
</code></pre>
<h3 id="complexity-n-is-length-of-the-array"><a class="header" href="#complexity-n-is-length-of-the-array">Complexity (\(n\) is length of the array)</a></h3>
<p><strong>Time complexity:</strong></p>
<ul>
<li>\( O(n \lg n) \)
<ul>
<li>For any Greedy algorithm, \( O(n \lg n + f(n) ) \) is its time complexity where \( f(n) \) is the time to check whether the current choice match the requirement of the problem (Technically, it is to check whether the choice makes an Independent Set, see <a href="https://en.wikipedia.org/wiki/Matroid">Wikipedia: Matroid</a>). Since, any concatenation of numbers makes valid number, in this case \( f(n)  = O(1) \)</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(n \lg n) \)
<ul>
<li>My implementation creates \( O(n \lg n) \) <code>String</code> for numerical comparison in total although they are create temporarily and <code>drop</code> quickly after comparison.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="322-coin-change"><a class="header" href="#322-coin-change">322. Coin Change</a></h1>
<h2 id="description-of-the-problem-16"><a class="header" href="#description-of-the-problem-16">Description of the Problem</a></h2>
<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer amount representing a total <code>amount</code> of money.</p>
<p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: coins = [2], amount = 3
Output: -1
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: coins = [1], amount = 0
Output: 0
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 2^31 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 10^4</code>.</li>
</ul>
<h2 id="solution-20"><a class="header" href="#solution-20">Solution</a></h2>
<h3 id="explanation-18"><a class="header" href="#explanation-18">Explanation</a></h3>
<p>Intuitively, if the amount of coins is &quot;divisible&quot;, the fewest possible number of coins is <code>1</code>. Thus, if the amount is equals to one of the denominations, then it should return <code>1</code>.</p>
<p>For any amount of coins, we can try every possible denominator to find the minimum number of coins. See the following equations:</p>
<p>\[ 
\text{min_coins}(n) =
\begin{cases}
0 &amp; \text{if n is 0} \\
1 &amp; \text{if n is one of the denominators} \\
+\infty &amp; \text{if n is negative} \\
\min_{c \ \in \ Denominators} \{ 1 + \text{min_coins}(n-c) \} &amp; \text{otherwise}
\end{cases}
\]</p>
<p>However, recursive approach may be very slow. It is more preferable to use Dynamic Programming approach because each solution is depended on smaller sub-solution.</p>
<h3 id="code-1"><a class="header" href="#code-1">Code</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn coin_change(coins: Vec&lt;i32&gt;, amount: i32) -&gt; i32 {
        let amount = amount as usize;
        let mut dp = vec![None ; amount + 1];
        dp[0] = Some(0);
        for i in 1..=amount{
            for &amp;chosen_coin in coins.iter() {
                if i &gt;= chosen_coin as usize {
                    let mx = dp[i];
                    let my = dp[i-chosen_coin as usize];
                    dp[i] = match (mx,my){
                        (None,None)=&gt;None,
                        (Some(x),None)=&gt;Some(x),
                        (None,Some(y))=&gt;Some(y+1),
                        (Some(x),Some(y))=&gt;Some(x.min(y+1)),
                    };
                }

            }
        }

        if let Some(sol) = dp[amount] { sol } else { -1 }
    }

}
</code></pre>
<h3 id="complexity-7"><a class="header" href="#complexity-7">Complexity</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\(O(n k)\)
<ul>
<li>\(n\) is amount of money and \(k\) is number of coins of different denominations</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( \Theta(n) \)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="347-top-k-frequent-elements"><a class="header" href="#347-top-k-frequent-elements">347. Top K Frequent Elements</a></h1>
<h2 id="description-of-the-problem-17"><a class="header" href="#description-of-the-problem-17">Description of the Problem</a></h2>
<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>. </p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [1], k = 1
Output: [1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>
<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>
</ul>
<p><strong>Follow up</strong>: Your algorithm's time complexity must be better than <code>O(n log n)</code>, where n is the array's size.</p>
<h2 id="solution-21"><a class="header" href="#solution-21">Solution</a></h2>
<h3 id="explanation-19"><a class="header" href="#explanation-19">Explanation</a></h3>
<p>Count the number of occurrence of each number. Insert them into bounded-size min heap according to their number of occurrence. Since each insertion remove element with the smallest number of occurrence if the min heap is full, the remaining elements in the heap must be the Top K most-frequent elements.</p>
<h3 id="code-2"><a class="header" href="#code-2">Code</a></h3>
<pre><code class="language-Rust">use std::collections::{HashMap, BinaryHeap};

#[derive(Eq,PartialEq)]
struct Counter(i32,i32);

impl Ord for Counter {
    fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering{
        other.1.cmp(&amp;self.1)
    }
}

impl PartialOrd for Counter {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt;{
        Some(other.1.cmp(&amp;self.1))
    }
}

impl Solution {
    pub fn top_k_frequent(nums: Vec&lt;i32&gt;, k: i32) -&gt; Vec&lt;i32&gt; {
        let k = k as usize;
        let mut counterMap = HashMap::new();
        nums.into_iter().for_each(
            |n| {
                let mut count = counterMap.get_mut(&amp;n);
                if count.is_none(){
                    counterMap.insert(n,1);
                }else{
                    *count.unwrap() += 1;
                }
            }
        );

        let mut min_heap = BinaryHeap::new();

        counterMap.into_iter().for_each(
            |(key,val)| {
                min_heap.push(Counter(key,val));
                if min_heap.len() &gt; k {
                    min_heap.pop();
                }
            }
        );
        
        return min_heap.into_iter().rev().map(|Counter(v,_)| v ).collect::&lt;Vec&lt;i32&gt;&gt;();
    }
}
</code></pre>
<h3 id="complexity-n-is-the-size-of-array"><a class="header" href="#complexity-n-is-the-size-of-array">Complexity (n is the size of array)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>Worst case: \(O(n + n \log k)\)
<ul>
<li>\( n \) for counting</li>
<li>\(\log k\) for insertion of an element in bounded min heap</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(n) \)
<ul>
<li>The size of counter is bound by the number of elements.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="371-sum-of-two-integers"><a class="header" href="#371-sum-of-two-integers">371. Sum of Two Integers</a></h1>
<h2 id="description-of-the-problem-18"><a class="header" href="#description-of-the-problem-18">Description of the Problem</a></h2>
<p>Given two integers <code>a</code> and <code>b</code>, return <em>the sum of the two integers without using the operators <code>+</code> and <code>-</code></em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: a = 1, b = 2
Output: 3
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: a = 2, b = 3
Output: 5
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>-1000 &lt;= a, b &lt;= 1000</code></li>
</ul>
<h2 id="solution-22"><a class="header" href="#solution-22">Solution</a></h2>
<h3 id="explanation-20"><a class="header" href="#explanation-20">Explanation</a></h3>
<p>The following code explains itself if you know how to perform addition of binary numbers by yourself.</p>
<h3 id="code-rust-13"><a class="header" href="#code-rust-13">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn get_sum(a: i32, b: i32) -&gt; i32 {
        let mut a = a;
        let mut b = b;
        
        while(b != 0){
            let sum = a ^ b;
            let carry = a &amp; b;
            a = sum;
            b = carry &lt;&lt; 1;
        }

        return a;
    }
}
</code></pre>
<h3 id="complexity-m-is-the-length-of-list1-and-n-is-the-length-of-list2-1"><a class="header" href="#complexity-m-is-the-length-of-list1-and-n-is-the-length-of-list2-1">Complexity (m is the length of list1 and n is the length of list2)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\(O(1)\)
<ul>
<li>In lowest level the time is bound by a constant since the number of bits in an integer is constant</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(1) \)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="518-coin-change-ii"><a class="header" href="#518-coin-change-ii">518. Coin Change II</a></h1>
<h2 id="description-of-problem-4"><a class="header" href="#description-of-problem-4">Description of Problem</a></h2>
<p>You are given an integer array coins representing <code>coins</code> of different denominations and an integer amount representing a total amount of money.</p>
<p><em>Return the number of combinations that make up that amount.</em> If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<p>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
</code></pre>
<p>Example 3:</p>
<pre><code>Input: amount = 10, coins = [10]
Output: 1
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 300</code></li>
<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>
<li>All the values of <code>coins</code> are <strong>unique</strong>.</li>
<li><code>0 &lt;= amount &lt;= 5000</code></li>
</ul>
<h2 id="solution-23"><a class="header" href="#solution-23">Solution</a></h2>
<h3 id="explanation-21"><a class="header" href="#explanation-21">Explanation</a></h3>
<h4 id="binary-selection-method"><a class="header" href="#binary-selection-method">Binary Selection Method</a></h4>
<p>If the amount is a positive number and the number of coins available is not zero, then there are two disjoint cases: to use the current coin and not to use it. (see the following equations)</p>
<p>\[ 
w(coins, sum) =
\begin{cases}
0 &amp; \text{if } sum \lt 0 \\
1 &amp; \text{if } sum = 0 \\
0 &amp; \text{if } sum \gt 0 \land coins = \varnothing \\
w(coins, sum - c) + w(coins \setminus \{ c \} , sum)  &amp; \text{otherwise; for some c in coins}
\end{cases}
\]</p>
<h4 id="dynamic-programming-using-less-space"><a class="header" href="#dynamic-programming-using-less-space">Dynamic Programming using less space</a></h4>
<p>We can also use less space. If we rewrite the recursive equation, you will get the update equation of 1-D DP table. </p>
<p>(<code>coin_idx</code> indicates that <code>coins[0]</code> to <code>coins[coin_indx]</code> are avaiable coins and <code>coins[coin_indx]</code> is the current selection.)</p>
<p>\[ w(coin\_idx, sum) = w(coins, sum - coins[ coin\_idx ]) + w(coin\_idx - 1 , sum) \]
\[ \Longleftrightarrow w(sum)^{(t)} = w(sum - coins[ t ])^{(t)} + w(sum)^{(t - 1)} \]</p>
<h3 id="code-rust-14"><a class="header" href="#code-rust-14">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn change(amount: i32, coins: Vec&lt;i32&gt;) -&gt; i32 {
        let m = amount as usize;
        let n = coins.len();

        let mut dp = vec![ vec![0; m+1]; n ];

        // If it is divisible by the smallest coin
        for (j,x) in (0..=amount).enumerate() {
            dp[0][j] = if x % coins[0] == 0 {1} else {0};
        }

        // Use the equations
        for i in 1..n {
            for j in 0..=m {
                let c = coins[i] as usize;
                dp[i][j] = 
                    if j &gt;= c { dp[i][j-c] } else {0}
                    + if i &gt; 0 { dp[i-1][j] } else {0}
            }
        }

        dp[n-1][m]
    }
}
</code></pre>
<h3 id="code-rust---with-less-space"><a class="header" href="#code-rust---with-less-space">Code (Rust) - With less Space</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn change(amount: i32, coins: Vec&lt;i32&gt;) -&gt; i32 {
        let m = amount as usize;
        let n = coins.len();

        let mut dp = vec![ 0; m+1 ];

        dp[0] = 1;

        for i in 0..n {
            for j in 1..=m {
                let c = coins[i] as usize;
                dp[j] += if j &gt;= c { dp[j-c] } else {0}
            }
        }

        dp[m]
    }
}
</code></pre>
<h3 id="complexity-m-is-the-amount-and-n-is-number-of-coins"><a class="header" href="#complexity-m-is-the-amount-and-n-is-number-of-coins">Complexity (m is the amount and n is number of coins)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\(O(mn)\)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(m) \)</li>
</ul>
<h2 id="further-discussion-2"><a class="header" href="#further-discussion-2">Further Discussion</a></h2>
<ul>
<li>For more optimised solution see <a href="https://leetcode.com/problems/coin-change-ii/solutions/3892702/100-dynamic-programming-video-optimal-solution/">vanAmsen's solution</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="435-non-overlapping-intervals"><a class="header" href="#435-non-overlapping-intervals">435. Non-overlapping Intervals</a></h1>
<h2 id="description-of-the-problem-19"><a class="header" href="#description-of-the-problem-19">Description of the Problem</a></h2>
<p>Given an array of intervals intervals where <code>intervals[i] = [starti, endi]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 105</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>-5 * 10^4 &lt;= starti &lt; endi &lt;= 5 * 10^4</code></li>
</ul>
<h2 id="solution-24"><a class="header" href="#solution-24">Solution</a></h2>
<h3 id="explanation-22"><a class="header" href="#explanation-22">Explanation</a></h3>
<p>The problem is equivalent to classical <strong>Activity Selection Problem</strong> which is to maximise the number of compatiable activities. Thus, in the following explanation, we assume that our goal is to maximise the number of activities in our schdule.</p>
<p>To solve the above problem, we choose activities one-by-one with earliest finish time (Greedy Algorithm).</p>
<p><strong>Optimal Substructure Property</strong></p>
<p>Suppose an activity \(a_k\) with interval \((s_k, f_k)\) is in optimal schedule from \(f_i\) to \(s_j\). The optimal solution can be divided into 3 parts: \( A_{ik} \cup a_k \cup A_{kj} \) where \( A_{ik} \) is optimal schedule start after \(f_i\) and finsih before \(s_k\) and \( A_{kj} \) is optimal schedule start after \(f_k\) and finsih before \(s_j\).</p>
<p>In other word, we can use Divide-and-Conquer to find optimal solution. i.e. choose an activity \(a_k\) such that the combined solution is maximum.</p>
<p>\[ \arg\max_{k} | A_{0k} \cup a_k \cup A_{kn} | \]</p>
<p><strong>Greedy-choice Property</strong></p>
<p>Suppose we have an optimal schedule \(A^*\) contains \(a_k\) which has earliest finish time in \( A^* \). </p>
<p>Suppose \( a_j \) has earliest finish time in the set of activities. </p>
<p>Replace \( a_k \) by \( a_j \) still yield the optimal schedule.</p>
<h3 id="code-java-7"><a class="header" href="#code-java-7">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (ai, aj) -&gt;  ai[1] - aj[1]);
        int count = 0;
        final int [] prev = intervals[0];
        int prev_start = prev[0];
        int prev_end = prev[1];

        for(int i = 1; i &lt; intervals.length; i++){
            int[] curr = intervals[i];
            int curr_start = curr[0];
            int curr_end = curr[1];
            if(curr_start &lt; prev_end ){
                count ++;
            }
            else{
                prev_start = curr_start;
                prev_end = curr_end;
            }
        }

        return count;
    }
}
</code></pre>
<h3 id="complexity-8"><a class="header" href="#complexity-8">Complexity</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\(O(n\lg n + n)\)
<ul>
<li>Sorting + Selection</li>
</ul>
</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( O(1) \)</li>
</ul>
<h2 id="further-discussion-3"><a class="header" href="#further-discussion-3">Further Discussion</a></h2>
<p>It is absolutely a bad way to implement a tuple <code>(a, b)</code> by Array. Especially since Rust support tuples, storing two number (start time and finish time) in Vector is not the good practice. The following code is alternative implementation and solution.</p>
<pre><code class="language-Rust">type Interval = (i32, i32);

struct Solution{}

impl Solution {
    pub fn erase_overlap_intervals(intervals: Vec&lt;Interval&gt;) -&gt; i32 {
        let mut intervals = intervals;
        intervals.sort_by( |(_,f1), (_,f2)| f1.cmp(&amp;f2) );
        let mut count = 0;
        let (mut prev_start, mut prev_end) = intervals[0];
        for (curr_start, curr_end) in intervals.into_iter().skip(1) {
            if curr_start &lt; prev_end {
                count += 1;
            }
            else{
                prev_start = curr_start;
                prev_end = curr_end;
            }
        }

        return count;
    }
}


fn main(){
    println!(&quot;{}&quot;, Solution::erase_overlap_intervals( vec![(1,2),(2,3),(3,4),(1,3)] ) );
    println!(&quot;{}&quot;, Solution::erase_overlap_intervals( vec![(1,2),(1,2),(1,2)] ) );
    println!(&quot;{}&quot;, Solution::erase_overlap_intervals( vec![(1,2),(2,3)] ) );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2095-delete-the-middle-node-of-a-linked-list"><a class="header" href="#2095-delete-the-middle-node-of-a-linked-list">2095. Delete the Middle Node of a Linked List</a></h1>
<h2 id="description-of-the-problem-20"><a class="header" href="#description-of-the-problem-20">Description of the Problem</a></h2>
<p>You are given the <code>head</code> of a linked list. <strong>Delete</strong> the <strong>middle node</strong>, and return the <code>head</code> <em>of the modified linked list</em>.</p>
<p>The <strong>middle node</strong> of a linked list of size <code>n</code> is the <code>⌊n / 2⌋th node</code> from the start using <strong>0-based indexing</strong>, where <code>⌊x⌋</code> denotes the largest integer less than or equal to <code>x</code>.</p>
<p>For <code>n</code> = <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>, the middle nodes are <code>0</code>, <code>1</code>, <code>1</code>, <code>2</code>, and <code>2</code>, respectively.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,3,4,7,1,2,6]
Output: [1,3,4,1,2,6]
Explanation:
The above figure represents the given linked list. The indices of the nodes are written below.
Since n = 7, node 3 with value 7 is the middle node, which is marked in red.
We return the new list after removing this node. 
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2,3,4]
Output: [1,2,4]
Explanation:
The above figure represents the given linked list.
For n = 4, node 2 with value 3 is the middle node, which is marked in red.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: head = [2,1]
Output: [2]
Explanation:
The above figure represents the given linked list.
For n = 2, node 1 with value 1 is the middle node, which is marked in red.
Node 0 with value 2 is the only node remaining after removing node 1.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is in the range [1, 10^5].</li>
<li>1 &lt;= Node.val &lt;= 10^5</li>
</ul>
<h2 id="solution-25"><a class="header" href="#solution-25">Solution</a></h2>
<h3 id="explanation-23"><a class="header" href="#explanation-23">Explanation</a></h3>
<p>It is almost the same as <a href="medium-problems/../easy-problems/876.html">876.	Middle of the Linked List</a> except we want both pointers move to left by 1 for deletion at the end of the loop. </p>
<p>To acheive this, we have to make sure that there is at least 3 nodes after the faster pointer before an iteration of loop. Hence, at the termination of the loop, the number of node must less than 3. The slow pointer always point to the previous node of the middle node.</p>
<h3 id="code-java-8"><a class="header" href="#code-java-8">Code (Java)</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {
    public ListNode deleteMiddle(ListNode head){
        if (head == null || head.next == null)
            return null;
        
        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null &amp;&amp; fast.next.next != null &amp;&amp; fast.next.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }

        slow.next = slow.next.next;

        return head;
    }
}
</code></pre>
<h3 id="code-c-3"><a class="header" href="#code-c-3">Code (C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {

public:
    ListNode* deleteMiddle(ListNode* head) {
        if (head == nullptr || head-&gt;next == nullptr)
            return nullptr;
        
        ListNode * slow = head;
        ListNode * fast = head;

        while (
            fast-&gt;next != nullptr 
            &amp;&amp; fast-&gt;next-&gt;next != nullptr 
            &amp;&amp; fast-&gt;next-&gt;next-&gt;next != nullptr
            ){
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }

        slow-&gt;next = slow-&gt;next-&gt;next;

        return head;
    }
};
</code></pre>
<h3 id="complexity-9"><a class="header" href="#complexity-9">Complexity</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\(T(n) = O(n/2)\)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\(S(n) = O(1)\)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="60-permutation-sequence"><a class="header" href="#60-permutation-sequence">60. Permutation Sequence</a></h1>
<h2 id="description-of-the-problem-21"><a class="header" href="#description-of-the-problem-21">Description of the Problem</a></h2>
<p>The set <code>[1, 2, 3, ..., n]</code> contains a total of <code>n!</code> unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for <code>n = 3</code>:</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>Given <code>n</code> and <code>k</code>, return the <code>kth</code> permutation sequence.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 3, k = 3
Output: &quot;213&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 4, k = 9
Output: &quot;2314&quot;
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: n = 3, k = 1
Output: &quot;123&quot;
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 9</code></li>
<li><code>1 &lt;= k &lt;= n!</code></li>
</ul>
<h2 id="solution-26"><a class="header" href="#solution-26">Solution</a></h2>
<p><strong>*The following explanation assume 0-based indexing which is different from the problem*</strong></p>
<h3 id="explanation-24"><a class="header" href="#explanation-24">Explanation</a></h3>
<p>\[ n! = \underbrace{n}_{\text{#possible choices for 1st element}} \cdot \underbrace{(n-1)!} _ {\text{#permutation start with specific element}} \]</p>
<p><strong>Example: n = 4, k = 13</strong></p>
<pre><code>0: 1234     6: 2134    12: 3124    18: 4123
1: 1243     7: 2143    13: 3142    19: 4132
2: 1324     8: 2314    14: 3214    20: 4213
3: 1342     9: 2341    15: 3241    21: 4231
4: 1423    10: 2413    16: 3412    22: 4312
5: 1432    11: 2431    17: 3421    23: 4321

Solution: 3142
</code></pre>
<p>Because:
\[ 
\underbrace{2} _{3!\text{: choose arr[2] from[1,2,3,4]}} \ <br />
\underbrace{0} _{2!\text{: choose arr[0] from[1,2,4]}} \ <br />
\underbrace{1} _{1!\text{: choose arr[1] from[2,4]}} \ <br />
\underbrace{0} _{0!\text{: choose arr[0] from[2]}} 
\]</p>
<p>As we see, there are \( (n−1)! \) permutations start with some particular element.</p>
<p>Thus, the element we want to find is in position \(\left \lfloor \frac{index}{(n-1)!} \right \rfloor\) in sorted array.</p>
<p>For the permutation of remaining (n-1) elements, the index for this sub-permutation will be \( \text{index} \ mod (n−1)! \) because \(divisor \cdot quotient + remainder = original \ number\).</p>
<p>Therefore, we can use the same method for (\(n-1)\) elements with \(\text{index′}=\text{index} \ mod (n−1)! \)</p>
<h3 id="code-rust-15"><a class="header" href="#code-rust-15">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    fn fact(n: usize) -&gt; usize{
        if n &lt;= 1 {
            1
        }else{
            (2..=n).product()
        }
    }

    fn dfs( choice : Vec&lt;usize&gt;, index: usize) -&gt; String{

        if choice.is_empty() {
            return String::from(&quot;&quot;);
        }

        if index == 0 {
            return choice.into_iter().map(|x| x.to_string()).collect::&lt;String&gt;();
        }

        let mut choice = choice;
        let group_size = Solution::fact(choice.len() - 1);
        let group_index = index / group_size;
        let subgroup_index = index % group_size;

        let left = choice.remove(group_index).to_string();
        let right = Solution::dfs(choice,subgroup_index);

        return [left, right].join(&quot;&quot;);

    }

    pub fn get_permutation(n: i32, k: i32) -&gt; String{
        let n = n as usize;
        let k = k as usize;
        let mut choice = (1..=n).collect::&lt;Vec&lt;usize&gt;&gt;();
        return Solution::dfs(choice, k - 1);
    }
}
</code></pre>
<h3 id="complexity-10"><a class="header" href="#complexity-10">Complexity</a></h3>
<ul>
<li>Time Complexity
<ul>
<li>\(T(n) = \mathcal{\Theta(n)}\)</li>
</ul>
</li>
<li>Auxiliary Space
<ul>
<li>\(S(n) = \mathcal{\Theta(n)}\)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="65-valid-number"><a class="header" href="#65-valid-number">65. Valid Number</a></h1>
<h2 id="description-of-the-problem-22"><a class="header" href="#description-of-the-problem-22">Description of the Problem</a></h2>
<p>A <strong>valid number</strong> can be split up into these components (in order):</p>
<ol>
<li>A <strong>decimal number</strong> or an <strong>integer</strong>.</li>
<li>(Optional) An <code>'e'</code> or <code>'E'</code>, followed by an integer.</li>
</ol>
<p>A <strong>decimal number</strong> can be split up into these components (in order):</p>
<ol>
<li>(Optional) A sign character (either <code>'+'</code> or <code>'-'</code>).</li>
<li>One of the following formats:
<ol>
<li>One or more digits, followed by a dot <code>'.'</code>.</li>
<li>One or more digits, followed by a dot <code>'.'</code>, followed by one or more digits.</li>
<li>A dot <code>'.'</code>, followed by one or more digits.</li>
</ol>
</li>
</ol>
<p>An <strong>integer</strong> can be split up into these components (in order):</p>
<ol>
<li>(Optional) A sign character (either <code>'+'</code> or <code>'-'</code>).</li>
<li>One or more digits.</li>
</ol>
<p>For example, all the following are valid numbers: <code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;], while the following are not valid numbers: [&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code>.</p>
<p>Given a string <code>s</code>, return <code>true</code> if <code>s</code> is a valid number.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;0&quot;
Output: true
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;e&quot;
Output: false
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot;.&quot;
Output: false
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>'+'</code>, minus <code>'-'</code>, or dot <code>'.'</code>.</li>
</ul>
<h2 id="solution-27"><a class="header" href="#solution-27">Solution</a></h2>
<p>For any problem about format. I suggest every one first to write a <strong>Extended Backus-Naur Form</strong> or <strong>Regular Expression</strong> to represent correct format.</p>
<p>We can split the string by special char such as <code>e</code>, <code>E</code> and <code>.</code> and check the validity of substrings.</p>
<h3 id="explanation-25"><a class="header" href="#explanation-25">Explanation</a></h3>
<h4 id="extended-backus-naur-form-of-valid-number"><a class="header" href="#extended-backus-naur-form-of-valid-number">Extended Backus-Naur Form of Valid Number</a></h4>
<p>\( \langle goal \rangle ::= (\text{'+'} | \text{'-'})? \langle base \rangle  ((\text{'e'}|\text{'E'})?\langle  expo \rangle )? \)</p>
<p>\(\langle  expo \rangle ::= (\text{'+'} | \text{'-'})? \langle  digits \rangle \)</p>
<p>\(\langle  base \rangle ::= \langle  digits \rangle \)</p>
<p>\( \ | \langle  digits \rangle  \text{'.'}  \)</p>
<p>\( \ | \ \text{'.'} \langle  digits \rangle \)</p>
<p>\( \ |  \langle  digits \rangle  \text{'.'} \langle  digits \rangle  \)</p>
<p>\( \langle  digits \rangle ::= (\text{'0'} | \text{'1'} | ... | \text{'9'})^+  \)</p>
<h3 id="code-rust-16"><a class="header" href="#code-rust-16">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {

    fn split_at_char(s: &amp;str, v : char) -&gt; (&amp;str, &amp;str){
        let option_index = s.find(v);

        return match option_index {
            Some(index) =&gt; {
                let len = s.len();

                // Exclude the character we found
                return (&amp;s[0..index], &amp;s[index+1..len]);
            },
            None =&gt; (s, &amp;&quot;&quot;),
        }

    }

    #[inline]
    fn process_first_char( s : &amp;str) -&gt; &amp;str{
        return if s.len() &gt; 0 {
            if s[0..1].find(&quot;+&quot;).is_some() || s[0..1].find(&quot;-&quot;).is_some() {&amp;s[1..]} else {s}
        }
        else {
            s
        };
    }

    fn is_digits(s: &amp;str, is_empty_true : bool) -&gt; bool{
        for c in s.chars() {
            match c {
                '0'..='9' =&gt; {},
                _ =&gt; {return false;},
            }
        }

        return if s == &quot;&quot; { is_empty_true } else { true };
    }

    fn is_signed_digits(s: &amp;str, is_empty_true : bool) -&gt; bool{
        let s = Solution::process_first_char(s);
        return Solution::is_digits(s, is_empty_true);
    }

    // Principal function of Solution
    pub fn is_number(s: String) -&gt; bool {
        if s.len() == 0 {
            return false;
        }

        let s = Solution::process_first_char(&amp;s);

        // Determine 'e' or 'E'
        let char_e = match ( s.find('e'), s.find('E') ) {
            (None,None) =&gt; { '\0' }, // dummy value
            (None,Some(_)) =&gt; { 'E' },
            (Some(_),None) =&gt; { 'e' },
            (Some(_),Some(_)) =&gt; { 'e' },
        };

        let (base, expo) = Solution::split_at_char(s, char_e);
        let (lhs, rhs) = Solution::split_at_char(base, '.');

        let (has_dot, has_e) = (
                s.find('.').is_some(),
                s.find('e').is_some() || s.find('E').is_some()
        );

        return match (has_dot, has_e) {

            // Case: &lt;base&gt; ('e'|'E') &lt;expo&gt;
            (true, true) =&gt;
                (lhs.len() &gt; 0 || rhs.len() &gt; 0) &amp;&amp;
                Solution::is_digits(lhs, true) &amp;&amp;
                Solution::is_digits(rhs, true) &amp;&amp;
                Solution::is_signed_digits(expo, false),

            // Case: &lt;lhs&gt;? '.' &lt;rhs&gt;?
            //      =&gt; &lt;lhs&gt; '.' &lt;rhs&gt;
            //      =&gt; '.' &lt;rhs&gt;
            //      =&gt; &lt;lhs&gt; '.'
            (true, false) =&gt;
                (lhs.len() &gt; 0 || rhs.len() &gt;0) &amp;&amp;
                Solution::is_digits(lhs, true) &amp;&amp;
                Solution::is_digits(rhs, true),

            // Case: &lt;base&gt; ('e'|'E') &lt;expo&gt;
            (false, true) =&gt;
                Solution::is_digits(lhs, false) &amp;&amp;
                Solution::is_signed_digits(expo, false),

            // Case: &lt;base&gt;
            (false, false) =&gt; Solution::is_digits(lhs, false),

        };
    }

}
</code></pre>
<h3 id="complexity-n-is-the-length-of-string"><a class="header" href="#complexity-n-is-the-length-of-string">Complexity (n is the length of string)</a></h3>
<p><strong>Time complexity:</strong> </p>
<ul>
<li>\( T(n) = \Theta(n) \)</li>
</ul>
<p><strong>Auxiliary Space:</strong></p>
<ul>
<li>\( S(n) = O(1) \)</li>
</ul>
<h2 id="further-discussion-4"><a class="header" href="#further-discussion-4">Further Discussion</a></h2>
<p>It is not difficult to see that this type of problems (i.e. Parsing) can be easily to solved by Haskell (Especially if we use Parser library such as <code>ParSec</code>). If I were an interviewee I would argue that it is suitable to use functional programming language instead of the imperative one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="239-sliding-window-maximum"><a class="header" href="#239-sliding-window-maximum">239. Sliding Window Maximum</a></h1>
<h2 id="description-of-the-problem-23"><a class="header" href="#description-of-the-problem-23">Description of the Problem</a></h2>
<p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return the <em>max sliding window</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [1], k = 1
Output: [1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h2 id="solution-28"><a class="header" href="#solution-28">Solution</a></h2>
<p>The idea of solution is not largely come from myself. However, I would provide my explanation to show the correctness of the method.</p>
<h3 id="explanation-26"><a class="header" href="#explanation-26">Explanation</a></h3>
<p><strong>Use Deque with some constrains</strong></p>
<p>Without loss of generality, assume the Deque stores tuples <code>(i, x)</code> where <code>i</code> is the index of <code>x</code> in array <code>nums</code></p>
<p><strong>Loop Invariant</strong> of the Deque \(d\): In j-th iteration, if the Deque \(d\) is not empty, then the following must be true</p>
<ol>
<li>\( j \le d.head \land d.tail \lt j + k \ \) where \(k\) is the size of window</li>
<li>For any pair of tuples \((i, x)\), \((j, y)\) in the Deque \(d\): If \((i, x)\) is stored before \((j, y)\), then \(x\) must greater than \(y\). In other word, the Deque stores elements in descending order.</li>
</ol>
<p>(1) is to ensure the values in the Deque are in the current window.</p>
<p>(2) is to ensure that the head of the Deque is always the largest element.</p>
<p>To make (1) true, remove 1 element from the head when moving window to the right</p>
<p>To make (2) true, before inserting the right-most element, remove all smaller elements from the tail.</p>
<h3 id="code-java-9"><a class="header" href="#code-java-9">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int [] ans = new int[ n - k + 1 ];
        Deque&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        for(int j = 0; j &lt; k; j++){
            while(q.size() != 0 &amp;&amp; nums[q.peekLast()] &lt; nums[j]){
                q.pollLast();
            }
            q.offerLast(j);
        }
        ans[0] = nums[q.peekFirst()];

        for(int i = 1; i &lt;= n - k; i++){
            while(q.size() != 0 &amp;&amp; q.peekFirst() &lt; i){
                q.pollFirst();
            }

            while(q.size() != 0 &amp;&amp; nums[q.peekLast()] &lt; nums[i + k - 1]){
                q.pollLast();
            }
            q.offerLast(i + k - 1);
            ans[i] = nums[q.peekFirst()];
        }

        return ans;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-palindrome-number"><a class="header" href="#9-palindrome-number">9. Palindrome Number</a></h1>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Given an integer <code>x</code>, return <code>true</code> <em>if <code>x</code> is a palindrome, and <code>false</code> otherwise</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>-2^31 &lt;= x &lt;= 2^31 - 1</code></li>
</ul>
<p><strong>Follow up</strong>: Could you solve it without converting the integer to a string?</p>
<h2 id="solution-29"><a class="header" href="#solution-29">Solution</a></h2>
<h3 id="code-rust-17"><a class="header" href="#code-rust-17">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    // Numerical Way
    pub fn is_palindrome(x: i32) -&gt; bool {
        if x &lt; 0 {
            return false;
        }
        else{
            let mut sum = 0;
            let mut x_copy = x;

            while x_copy &gt; 0{
                sum *= 10; // Sum shifts left by 1
                sum += x_copy % 10; // Extract bit
                x_copy /= 10; // x_copy shifts right by 1
            }
            return sum == x;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-valid-parentheses"><a class="header" href="#20-valid-parentheses">20. Valid Parentheses</a></h1>
<h2 id="description-of-the-problem-24"><a class="header" href="#description-of-the-problem-24">Description of the Problem</a></h2>
<p>Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>,<code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;()&quot;
Output: true
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;()[]{}&quot;
Output: true
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot;(]&quot;
Output: false
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^4</code></li>
<li><code>s</code> consists of parentheses only <code>'()[]{}'</code>.</li>
</ul>
<h2 id="solution-30"><a class="header" href="#solution-30">Solution</a></h2>
<h3 id="coderust-1"><a class="header" href="#coderust-1">Code(Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn is_valid(s: String) -&gt; bool {
        let mut stack = Vec::new();
        for i in s.chars() {
            match i {
                '{' =&gt; stack.push('}'),
                '(' =&gt; stack.push(')'),
                '[' =&gt; stack.push(']'),
                '}'|')'|']' if Some(i) != stack.pop() =&gt; return false,
                _ =&gt; (),
            }
        }   
        return stack.is_empty();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-merge-two-sorted-lists"><a class="header" href="#21-merge-two-sorted-lists">21. Merge Two Sorted Lists</a></h1>
<h2 id="description-of-the-problem-25"><a class="header" href="#description-of-the-problem-25">Description of the Problem</a></h2>
<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>
<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return the head of the <em>merged linked list</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: list1 = [], list2 = []
Output: []
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: list1 = [], list2 = [0]
Output: [0]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>Both <code>list1</code> and <code>list2</code> are sorted in non-decreasing order.</li>
</ul>
<h2 id="solution-31"><a class="header" href="#solution-31">Solution</a></h2>
<h3 id="code-java-10"><a class="header" href="#code-java-10">Code (Java)</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode(0);
        ListNode curr = dummyHead;
        while(list1 != null &amp;&amp; list2 != null){
            if(list1.val &lt; list2.val){
                curr.next = list1;
                list1 = list1.next;
            }
            else{
                curr.next = list2;
                list2 = list2.next;
            }
            curr = curr.next;
        }

         if(list1 != null){
             curr.next = list1;
         }else{
             curr.next = list2;
         }

        return dummyHead.next;
    }
}
</code></pre>
<h3 id="code-rust-18"><a class="header" href="#code-rust-18">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -&gt; Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn merge_two_lists(list1: Option&lt;Box&lt;ListNode&gt;&gt;, list2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut left_head = list1;
        let mut right_head = list2;
        let mut curr_head = None;

        // 
        while left_head.is_some() &amp;&amp; right_head.is_some() {
            if let (Some(mut left_node), Some(mut right_node)) = (left_head.take(), right_head.take()){
                if left_node.val &lt; right_node.val {
                    left_head = left_node.next.take();
                    right_head = Some(right_node);
                    if curr_head.is_some(){
                        left_node.next = curr_head;   
                    }
                    curr_head = Some(left_node);
                }else{
                    right_head = right_node.next.take();
                    left_head = Some(left_node);
                    if curr_head.is_some(){
                        right_node.next = curr_head;
                    }
                    curr_head = Some(right_node);
                }
                
            }
        }

        while let Some(mut left_node) = left_head.take(){
            left_head = left_node.next.take();
            if curr_head.is_some(){
                left_node.next = curr_head;
            }
            curr_head = Some(left_node);
        }

        while let Some(mut right_node) = right_head.take(){
            right_head = right_node.next.take();
            if curr_head.is_some(){
                right_node.next = curr_head;
            }
            curr_head = Some(right_node);
        }

        return Solution::reverse_list(curr_head);
    }

    #[inline(always)]
    fn reverse_list(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt;{
        let mut curr = head;
        let mut prev = None;
        while let Some(mut node) = curr.take(){
            curr = node.next;
            node.next = prev;
            prev = Some(node);
        }

        return prev;
    }
}
</code></pre>
<h3 id="code-c-4"><a class="header" href="#code-c-4">Code (C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode * dummyHead = new ListNode();
        ListNode * curr = dummyHead;

        while (list1 != nullptr &amp;&amp; list2 != nullptr){
            if(list1-&gt;val &lt;= list2-&gt;val){
                curr-&gt;next = list1;
                list1 = list1-&gt;next;
            }
            else{
                curr-&gt;next = list2;
                list2 = list2-&gt;next;
            }
            curr = curr-&gt;next;
        }

        while (list1 != nullptr){
            curr-&gt;next = list1;
            list1 = list1-&gt;next;
            curr = curr-&gt;next;
        }

        while (list2 != nullptr){
            curr-&gt;next = list2;
            list2 = list2-&gt;next;
            curr = curr-&gt;next;
        }

        return dummyHead-&gt;next;

    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="26-remove-duplicates-from-sorted-array"><a class="header" href="#26-remove-duplicates-from-sorted-array">26. Remove Duplicates from Sorted Array</a></h1>
<h2 id="description-of-problem-5"><a class="header" href="#description-of-problem-5">Description of Problem</a></h2>
<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates in-place such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>. Then return the number of unique elements in <code>nums</code>.</p>
<p>Consider the number of unique elements of <code>nums</code> to be <code>k</code>, to get accepted, you need to do the following things:</p>
<ul>
<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the unique elements in the order they were present in <code>nums</code> initially. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>
<li>Return <code>k</code>.</li>
</ul>
<p><strong>Custom Judge:</strong></p>
<pre><code>The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre>
<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
<li><code>nums</code> is sorted in <strong>non-decreasing order</strong>.</li>
</ul>
<h2 id="solution-32"><a class="header" href="#solution-32">Solution</a></h2>
<h3 id="code-java-11"><a class="header" href="#code-java-11">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public int removeDuplicates(int[] nums) {
        int length = 0;
        Integer prevEle = null;
        for(int i = 0; i &lt; nums.length; i++){
            Integer currEle = nums[i];
            if (!currEle.equals(prevEle)){
                nums[length] = nums[i];
                prevEle = nums[i];
                length++;
             }
        }

        return length;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="83-remove-duplicates-from-sorted-list"><a class="header" href="#83-remove-duplicates-from-sorted-list">83. Remove Duplicates from Sorted List</a></h1>
<h2 id="description-of-problem-6"><a class="header" href="#description-of-problem-6">Description of Problem</a></h2>
<p>Given the <code>head</code> of a sorted linked list, <em>delete all duplicates such that each element appears only once. Return the linked list <strong>sorted</strong> as well</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,1,2]
Output: [1,2]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,1,2,3,3]
Output: [1,2,3]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>The list is guaranteed to be sorted in ascending order.</li>
</ul>
<h2 id="solution-33"><a class="header" href="#solution-33">Solution</a></h2>
<h3 id="code-java-12"><a class="header" href="#code-java-12">Code (Java)</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null){
            return head;
        }

        ListNode dummyHead = new ListNode(-101);
        ListNode currentNode = dummyHead;

        while(head != null){
            if(currentNode.val != head.val){
                currentNode.next = head;
                currentNode = currentNode.next;
            }
            head = head.next;
        }
        currentNode.next = null;

        return dummyHead.next;
        
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="94-binary-tree-inorder-traversal"><a class="header" href="#94-binary-tree-inorder-traversal">94. Binary Tree Inorder Traversal</a></h1>
<h2 id="description-of-problem-7"><a class="header" href="#description-of-problem-7">Description of Problem</a></h2>
<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes' values</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [1,null,2,3]
Output: [1,3,2]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = []
Output: []
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: root = [1]
Output: [1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>Follow up</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="solution-34"><a class="header" href="#solution-34">Solution</a></h2>
<h3 id="code-rust---recursion"><a class="header" href="#code-rust---recursion">Code (Rust) - Recursion</a></h3>
<pre><code class="language-Rust">// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -&gt; Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::borrow::BorrowMut;
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn inorder_traversal(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {
        let mut v : Vec&lt;i32&gt; = Vec::new();
        Solution::helper(root, &amp;mut v);
        return v;

    }

    fn helper(node: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, v : &amp;mut Vec&lt;i32&gt;){
        if let Some(node) = node{
            let node = node.borrow();
            Solution::helper(node.left.clone(), v);
            v.push(node.val);
            Solution::helper(node.right.clone(), v);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="100-same-tree"><a class="header" href="#100-same-tree">100. Same Tree</a></h1>
<h2 id="description-of-problem-8"><a class="header" href="#description-of-problem-8">Description of Problem</a></h2>
<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: p = [1,2,3], q = [1,2,3]
Output: true
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: p = [1,2], q = [1,null,2]
Output: false
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: p = [1,2,1], q = [1,1,2]
Output: false
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li>
<li>-10^4 &lt;= Node.val &lt;= 10^4</li>
</ul>
<h2 id="solution-35"><a class="header" href="#solution-35">Solution</a></h2>
<h3 id="coderust-2"><a class="header" href="#coderust-2">Code(Rust)</a></h3>
<pre><code class="language-Rust">// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -&gt; Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn is_same_tree(p: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, q: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {
        match (p, q) {
            (None, None) =&gt; return true,
            (None, _) =&gt; return false,
            (_, None) =&gt; return false,
            (Some(p), Some(q)) =&gt; {
                let p = p.borrow();
                let q = q.borrow();
                return p.val == q.val &amp;&amp; Self::is_same_tree(p.left.clone(), q.left.clone()) &amp;&amp; Self::is_same_tree(p.right.clone(), q.right.clone());
            }
        }
    }
}
</code></pre>
<h3 id="code-c-5"><a class="header" href="#code-c-5">Code (C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p == nullptr &amp;&amp; q == nullptr){
            return true;
        }
        else if(p != nullptr &amp;&amp; q != nullptr){
            return p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree (p-&gt;right, q-&gt;right);
        }
        else{
            return false;
        }

    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-minimum-depth-of-binary-tree"><a class="header" href="#111-minimum-depth-of-binary-tree">111. Minimum Depth of Binary Tree</a></h1>
<h2 id="description-of-the-problem-26"><a class="header" href="#description-of-the-problem-26">Description of the Problem</a></h2>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [3,9,20,null,null,15,7]
Output: 2
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 10^5]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="solution-36"><a class="header" href="#solution-36">Solution</a></h2>
<h3 id="code-c-6"><a class="header" href="#code-c-6">Code (C++)</a></h3>
<pre><code class="language-C++">class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        int left = minDepth(root-&gt;left);
        int right = minDepth(root-&gt;right);
        return left == 0 ^ right == 0 ? 
            1 + std::max(left, right) :
            1 + std::min(left, right);
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="112-path-sum"><a class="header" href="#112-path-sum">112. Path Sum</a></h1>
<h2 id="description-of-the-problem-27"><a class="header" href="#description-of-the-problem-27">Description of the Problem</a></h2>
<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>
<p>A leaf is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
Explanation: The root-to-leaf path with the target sum is shown.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = [1,2,3], targetSum = 5
Output: false
Explanation: There two root-to-leaf paths in the tree:
(1 --&gt; 2): The sum is 3.
(1 --&gt; 3): The sum is 4.
There is no root-to-leaf path with sum = 5.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: root = [], targetSum = 0
Output: false
Explanation: Since the tree is empty, there are no root-to-leaf paths.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
<li><code>1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="solution-37"><a class="header" href="#solution-37">Solution</a></h2>
<h3 id="code-rust-19"><a class="header" href="#code-rust-19">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -&gt; Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {

    pub fn has_path_sum(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, target_sum: i32) 
        -&gt; bool {
        match (root) {
            None =&gt; false,
            Some(root) =&gt; {
                let root = root.borrow();
                if root.left.is_none() 
                    &amp;&amp; root.right.is_none() 
                    &amp;&amp; root.val == target_sum {
                    true
                }else {
                    Solution::has_path_sum( 
                        root.left.clone(), target_sum - root.val
                    ) 
                    || Solution::has_path_sum( 
                        root.right.clone(), target_sum - root.val
                    )
                }
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="118-pascals-triangle"><a class="header" href="#118-pascals-triangle">118. Pascal's Triangle</a></h1>
<h2 id="description-of-the-problem-28"><a class="header" href="#description-of-the-problem-28">Description of the Problem</a></h2>
<p>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal's triangle</strong>.</p>
<p>In <strong>Pascal's triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: numRows = 1
Output: [[1]]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= numRows &lt;= 30</code></li>
</ul>
<h2 id="solution-38"><a class="header" href="#solution-38">Solution</a></h2>
<h3 id="code-rust-20"><a class="header" href="#code-rust-20">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn generate(num_rows: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        let mut result : Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();
        
        for n in 0..num_rows {
            let mut row : Vec&lt;i32&gt; = Vec::new();
            for i in 0..=n {
                row.push(
                    if i == n || i == 0 {
                        1
                    }
                    else{
                        result[(n - 1) as usize][(i - 1) as usize] 
                        + result[(n - 1) as usize][i as usize]
                    }
                )
            }
            result.push(row);
        }

        return result;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="125-valid-palindrome"><a class="header" href="#125-valid-palindrome">125. Valid Palindrome</a></h1>
<h2 id="description-of-the-problem-29"><a class="header" href="#description-of-the-problem-29">Description of the Problem</a></h2>
<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>
<p>Given a string <code>s</code>, return <code>true</code> if it is a <em>palindrome</em>, or <code>false</code> otherwise.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = &quot;A man, a plan, a canal: Panama&quot;
Output: true
Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = &quot;race a car&quot;
Output: false
Explanation: &quot;raceacar&quot; is not a palindrome.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: s = &quot; &quot;
Output: true
Explanation: s is an empty string &quot;&quot; after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2 * 10^5</code></li>
<li><code>s</code> consists only of printable ASCII characters.</li>
</ul>
<h2 id="solution-39"><a class="header" href="#solution-39">Solution</a></h2>
<h3 id="code-rust-21"><a class="header" href="#code-rust-21">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn is_palindrome(s: String) -&gt; bool {
        let mut s = s;
        s = s.to_lowercase();

        let s = s.chars().collect::&lt;Vec&lt;char&gt;&gt;();

        let mut i = 0;
        let mut j = s.len() - 1;

        while i &lt; j {
            let (a,b) = (s[i], s[j]);
            match ( a.is_alphanumeric(), b.is_alphanumeric() ) {
                (true, true) =&gt; if a != b {return false} else {i+=1; j-=1;},
                (true, false) =&gt; j-=1,
                (false, true) =&gt; i+=1,
                (false, false) =&gt; {i+1; j-=1;}
            }
        }

        return true;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="141-linked-list-cycle"><a class="header" href="#141-linked-list-cycle">141. Linked List Cycle</a></h1>
<h2 id="description-of-the-problem-30"><a class="header" href="#description-of-the-problem-30">Description of the Problem</a></h2>
<p>Given head, the <code>head</code> of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>
<p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of the nodes in the list is in the range <code>[0, 10^4]</code>.</li>
<li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li>
<li><code>pos</code> is <code>-1</code> or a valid index in the linked-list.</li>
</ul>
<p><strong>Follow up</strong>: Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>
<h2 id="solution-40"><a class="header" href="#solution-40">Solution</a></h2>
<h3 id="code-java-13"><a class="header" href="#code-java-13">Code (Java)</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head;
        while(slow.next != null &amp;&amp; fast.next != null &amp;&amp; fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast){
                return true;
            }
        }

        return false;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="144-binary-tree-preorder-traversal"><a class="header" href="#144-binary-tree-preorder-traversal">144. Binary Tree Preorder Traversal</a></h1>
<h2 id="description-of-problem-9"><a class="header" href="#description-of-problem-9">Description of Problem</a></h2>
<p>Given the <code>root</code> of a binary tree, return the preorder traversal of its nodes' values.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [1,null,2,3]
Output: [1,2,3]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = []
Output: []
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: root = [1]
Output: [1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>Follow up</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="solution-41"><a class="header" href="#solution-41">Solution</a></h2>
<h3 id="codec-1"><a class="header" href="#codec-1">Code(C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    void helper(TreeNode * root, vector&lt;int&gt; &amp;vec){
        if(root == nullptr) 
            return;
        vec.push_back(root-&gt;val);
        helper(root-&gt;left, vec);
        helper(root-&gt;right, vec);
        
    }

public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; vec;
        helper(root, vec);
        return vec;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="145-binary-tree-postorder-traversal"><a class="header" href="#145-binary-tree-postorder-traversal">145. Binary Tree Postorder Traversal</a></h1>
<h2 id="description-of-problem-10"><a class="header" href="#description-of-problem-10">Description of Problem</a></h2>
<p>Given the <code>root</code> of a binary tree, return the postorder traversal of its nodes' values.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [1,null,2,3]
Output: [3,2,1]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = []
Output: []
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: root = [1]
Output: [1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>Follow up</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="solution-42"><a class="header" href="#solution-42">Solution</a></h2>
<h3 id="code-c-7"><a class="header" href="#code-c-7">Code (C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    void helper(TreeNode * root, vector&lt;int&gt; &amp;vec){
        if(root == nullptr) 
            return;
        helper(root-&gt;left, vec);
        helper(root-&gt;right, vec);
        vec.push_back(root-&gt;val);
    }

public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; vec;
        helper(root, vec);
        return vec;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="191-number-of-1-bits"><a class="header" href="#191-number-of-1-bits">191. Number of 1 Bits</a></h1>
<h2 id="description-of-the-problem-31"><a class="header" href="#description-of-the-problem-31">Description of the Problem</a></h2>
<p>Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).</p>
<p>Note:</p>
<p>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: n = 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The input must be a binary string of length 32.</li>
</ul>
<p><strong>Follow up</strong>: If this function is called many times, how would you optimize it?</p>
<h2 id="solution-43"><a class="header" href="#solution-43">Solution</a></h2>
<h3 id="code-java-14"><a class="header" href="#code-java-14">Code (Java)</a></h3>
<pre><code class="language-Java">public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while( n != 0 ){
            count += n &amp; 1;
            n  = n &gt;&gt;&gt; 1; // Unsigned Right Shift
        }
        return count;
    }
}
</code></pre>
<h3 id="code-rust-22"><a class="header" href="#code-rust-22">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn hammingWeight (n: u32) -&gt; i32 {
        let mut n = n;
        let mut count = 0;
        while n != 0 {
            count += n &amp; 1;
            n  = n &gt;&gt; 1; // Unsigned Right Shift
        }
        return count as i32;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="193-valid-phone-numbers"><a class="header" href="#193-valid-phone-numbers">193. Valid Phone Numbers</a></h1>
<h2 id="description-of-problem-11"><a class="header" href="#description-of-problem-11">Description of Problem</a></h2>
<p>Given a text file <code>file.txt</code> that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.</p>
<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>
<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>
<p>Example:</p>
<p>Assume that <code>file.txt</code> has the following content:</p>
<pre><code>987-123-4567
123 456 7890
(123) 456-7890
</code></pre>
<p>Your script should output the following valid phone numbers:</p>
<pre><code>987-123-4567
(123) 456-7890
</code></pre>
<h2 id="solution-44"><a class="header" href="#solution-44">Solution</a></h2>
<h3 id="code-sh"><a class="header" href="#code-sh">Code (sh)</a></h3>
<pre><code class="language-sh"># Read from the file file.txt and output all valid phone numbers to stdout.
# Read from the file file.txt and output all valid phone numbers to stdout.
grep -E &quot;^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$&quot; file.txt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="195-tenth-line"><a class="header" href="#195-tenth-line">195. Tenth Line</a></h1>
<h2 id="description-of-problem-12"><a class="header" href="#description-of-problem-12">Description of Problem</a></h2>
<p>Given a text file <code>file.txt</code>, print just the 10th line of the file.</p>
<p>Example:</p>
<p>Assume that <code>file.txt</code> has the following content:</p>
<pre><code>Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
</code></pre>
<p>Your script should output the tenth line, which is:</p>
<pre><code>Line 10
</code></pre>
<p>Note:</p>
<ol>
<li>If the file contains less than 10 lines, what should you output?</li>
<li>There's at least three different solutions. Try to explore all possibilities.</li>
</ol>
<h2 id="solution-45"><a class="header" href="#solution-45">Solution</a></h2>
<h3 id="code-sh-1"><a class="header" href="#code-sh-1">Code (sh)</a></h3>
<pre><code class="language-sh">tail -n +10 file.txt | head -n 1
</code></pre>
<pre><code class="language-sh">awk 'NR == 10 {print; exit}' file.txt
</code></pre>
<pre><code class="language-sh">sed -n '10p' &lt; file.txt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="217-contains-duplicate"><a class="header" href="#217-contains-duplicate">217. Contains Duplicate</a></h1>
<h2 id="description-of-the-problem-32"><a class="header" href="#description-of-the-problem-32">Description of the Problem</a></h2>
<p>Given an integer array nums, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,2,3,1]
Output: true
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [1,2,3,4]
Output: false
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>10^9 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="solution-46"><a class="header" href="#solution-46">Solution</a></h2>
<h3 id="code-java-15"><a class="header" href="#code-java-15">Code (Java)</a></h3>
<pre><code class="language-Java">// import java.util.HashSet;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet &lt;Integer&gt; set = new HashSet();
        for (int n : nums){
            if (!set.add(n))
                return true;
        }
        return false;
    }
}
</code></pre>
<h3 id="coderust-3"><a class="header" href="#coderust-3">Code(Rust)</a></h3>
<pre><code class="language-Rust">use std::collections::HashSet;

impl Solution {
    pub fn contains_duplicate(nums: Vec&lt;i32&gt;) -&gt; bool {

        let mut set : HashSet&lt;i32&gt; = HashSet::new();
        for n in nums {
            if !set.insert(n) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="226-invert-binary-tree"><a class="header" href="#226-invert-binary-tree">226. Invert Binary Tree</a></h1>
<h2 id="description-of-the-problem-33"><a class="header" href="#description-of-the-problem-33">Description of the Problem</a></h2>
<p>Given the <code>root</code> of a binary tree, invert the tree, and return its <code>root</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = [2,1,3]
Output: [2,3,1]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: root = []
Output: []
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="solution-47"><a class="header" href="#solution-47">Solution</a></h2>
<h3 id="codec-2"><a class="header" href="#codec-2">Code(C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) 
            return nullptr;
        TreeNode * tempNode = root-&gt;left;
        root-&gt;left = invertTree(root-&gt;right);
        root-&gt;right = invertTree(tempNode);
        return root;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="292-nim-game"><a class="header" href="#292-nim-game">292. Nim Game</a></h1>
<h2 id="description-of-the-problem-34"><a class="header" href="#description-of-the-problem-34">Description of the Problem</a></h2>
<p>You are playing the following Nim Game with your friend:</p>
<ul>
<li>Initially, there is a heap of stones on the table.</li>
<li>You and your friend will alternate taking turns, and <strong>you go first</strong>.</li>
<li>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.</li>
<li>The one who removes the last stone is the winner.</li>
</ul>
<p>Given <code>n</code>, the number of stones in the heap, return <code>true</code> if you can win the game assuming both you and your friend play optimally, otherwise return <code>false</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 4
Output: false
Explanation: These are the possible outcomes:
1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.
2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.
3. You remove 3 stones. Your friend removes the last stone. Your friend wins.
In all outcomes, your friend wins.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 1
Output: true
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: n = 2
Output: true
</code></pre>
<p><strong>Constraints:</strong></p>
<p><code>1 &lt;= n &lt;= 2^31 - 1</code></p>
<h2 id="solution-48"><a class="header" href="#solution-48">Solution</a></h2>
<h3 id="code-java-16"><a class="header" href="#code-java-16">Code (Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public boolean canWinNim(int n) {
        return n % 4 != 0;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="231-power-of-two"><a class="header" href="#231-power-of-two">231. Power of Two</a></h1>
<h2 id="description-of-problem-13"><a class="header" href="#description-of-problem-13">Description of Problem</a></h2>
<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of two. Otherwise, return <code>false</code></em>.</p>
<p>An integer <code>n</code> is a power of two, if there exists an integer <code>x</code> such that <code>n == 2^x</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 1
Output: true
Explanation: 20 = 1
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 16
Output: true
Explanation: 24 = 16
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: n = 3
Output: false
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>-2^31 &lt;= n &lt;= 2^31 - 1</code></li>
</ul>
<p><strong>Follow up</strong>: Could you solve it without loops/recursion?</p>
<h2 id="solution-49"><a class="header" href="#solution-49">Solution</a></h2>
<h3 id="code-java---bitwise-operations"><a class="header" href="#code-java---bitwise-operations">Code (Java) - Bitwise operations</a></h3>
<pre><code class="language-Java">class Solution {
    public boolean isPowerOfTwo(int n) {

        if ( n&lt;= 0 ){
            return false;
        }
        
        while((n &amp; 1) == 0){
            n = n &gt;&gt; 1;
        }

        return n == 1 ;
    }
}
</code></pre>
<h3 id="code-java---meet-the-requirement-of-the-follow-up"><a class="header" href="#code-java---meet-the-requirement-of-the-follow-up">Code (Java) - Meet the requirement of the follow-up</a></h3>
<pre><code class="language-Java">class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n &lt;= 0) {
            return false;
        }else{
            return (1073741824 % n) == 0;
        } 
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="344-reverse-string"><a class="header" href="#344-reverse-string">344. Reverse String</a></h1>
<h2 id="description-of-the-problem-35"><a class="header" href="#description-of-the-problem-35">Description of the Problem</a></h2>
<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>
<p>You must do this by modifying the input array in-place with <code>O(1)</code> extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>1 &lt;= s.length &lt;= 10^5</li>
<li><code>s[i]</code> is a printable ascii character.</li>
</ul>
<h2 id="solution-50"><a class="header" href="#solution-50">Solution</a></h2>
<h3 id="coderust-4"><a class="header" href="#coderust-4">Code(Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn reverse_string(s: &amp;mut Vec&lt;char&gt;) {
        let (mut i, mut j) = (0, s.len() - 1);
        while( i &lt; j){
            let c = s[i];
            s[i] = s[j];
            s[j] = c;
            i+=1; j-=1;
        }
    }
}
</code></pre>
<h3 id="codejava-1"><a class="header" href="#codejava-1">Code(Java)</a></h3>
<pre><code class="language-Java">class Solution {
    public void reverseString(char[] s) {
        int i = 0; int j = s.length - 1;
        while( i &lt; j){
            char c = s[i];
            s[i] = s[j];
            s[j] = c;
            i++; j--;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="374-guess-number-higher-or-lower"><a class="header" href="#374-guess-number-higher-or-lower">374. Guess Number Higher or Lower</a></h1>
<h2 id="description-of-the-problem-36"><a class="header" href="#description-of-the-problem-36">Description of the Problem</a></h2>
<p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from <code>1</code> to <code>n</code>. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.</p>
<p>You call a pre-defined API <code>int guess(int num)</code>, which returns three possible results:</p>
<p><code>-1</code>: Your guess is higher than the number I picked (i.e. <code>num &gt; pick</code>).
<code>1</code>: Your guess is lower than the number I picked (i.e. <code>num &lt; pick</code>).
<code>0</code>: your guess is equal to the number I picked (i.e. <code>num == pick</code>).
Return <em>the number that I picked</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 10, pick = 6
Output: 6
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: n = 1, pick = 1
Output: 1
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: n = 2, pick = 1
Output: 1
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>1 &lt;= n &lt;= 2^31 - 1</li>
<li>1 &lt;= pick &lt;= n</li>
</ul>
<h2 id="solution-51"><a class="header" href="#solution-51">Solution</a></h2>
<h3 id="coderust-5"><a class="header" href="#coderust-5">Code(Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {

    unsafe fn guessNumber(n: i32) -&gt; i32 {
        let mut begin = 1;
        let mut i_end = n;
        let mut mid;
        loop{
            mid = begin + (i_end - begin) / 2;
            match guess(mid) {
                -1 =&gt; {i_end = mid - 1},
                0 =&gt; {break},
                1 =&gt; {begin = mid + 1},
                _ =&gt; panic!(),
            }
        };

        return mid;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="897-increasing-order-search-tree"><a class="header" href="#897-increasing-order-search-tree">897. Increasing Order Search Tree</a></h1>
<h2 id="description-of-the-problem-37"><a class="header" href="#description-of-the-problem-37">Description of the Problem</a></h2>
<p>Given the <code>root</code> of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = [5,1,7]
Output: [1,null,5,null,7]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="solution-52"><a class="header" href="#solution-52">Solution</a></h2>
<h3 id="codec-3"><a class="header" href="#codec-3">Code(C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* increasingBST(TreeNode* root) {
        if (root == nullptr)
            return nullptr;
        else if (root-&gt;left == nullptr){
            TreeNode * right = increasingBST(root-&gt;right);
            TreeNode * mid = new TreeNode(root-&gt;val);
            mid-&gt;right = right;
            return mid;
        }
        else{
            TreeNode * left = increasingBST(root-&gt;left);
            TreeNode * right = increasingBST(root-&gt;right);
            TreeNode * mid = new TreeNode(root-&gt;val);
            TreeNode * leftLeaf = left;
            while(leftLeaf -&gt; right != nullptr)
                leftLeaf = leftLeaf-&gt;right;

            leftLeaf-&gt;right = mid;
            mid-&gt;right = right;
            return left;
        }
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1290-convert-binary-number-in-a-linked-list-to-integer"><a class="header" href="#1290-convert-binary-number-in-a-linked-list-to-integer">1290. Convert Binary Number in a Linked List to Integer</a></h1>
<h2 id="description-of-the-problem-38"><a class="header" href="#description-of-the-problem-38">Description of the Problem</a></h2>
<p>Given <code>head</code> which is a reference node to a singly-linked list. The value of each node in the linked list is either <code>0</code> or <code>1</code>. The linked list holds the binary representation of a number.</p>
<p>Return the decimal value of the number in the linked list.</p>
<p>The <strong>most significant bit</strong> is at the head of the linked list.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,0,1]
Output: 5
Explanation: (101) in base 2 = (5) in base 10
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [0]
Output: 0
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The Linked List is not empty.</li>
<li>Number of nodes will not exceed <code>30</code>.</li>
<li>Each node's value is either <code>0</code> or <code>1</code>.</li>
</ul>
<h2 id="solution-53"><a class="header" href="#solution-53">Solution</a></h2>
<h3 id="code-rust-23"><a class="header" href="#code-rust-23">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -&gt; Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn get_decimal_value(head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; i32 {
        let mut head = head;
        let mut sum = 0;
        while let Some(node) = head.take() {
            sum = sum &lt;&lt; 1;
            sum ^= node.val;
            head = node.next;
        }
        return sum;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1822-sign-of-the-product-of-an-array"><a class="header" href="#1822-sign-of-the-product-of-an-array">1822. Sign of the Product of an Array</a></h1>
<h2 id="description-of-the-problem-39"><a class="header" href="#description-of-the-problem-39">Description of the Problem</a></h2>
<p>There is a function <code>signFunc(x)</code> that returns:</p>
<ul>
<li><code>1</code> if <code>x</code> is positive.</li>
<li><code>-1</code> if <code>x</code> is negative.</li>
<li><code>0</code> if <code>x</code> is equal to <code>0</code>.
You are given an integer array <code>nums</code>. Let <code>product</code> be the product of all values in the array <code>nums</code>.</li>
</ul>
<p>Return <code>signFunc(product)</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [-1,-2,-3,-4,3,2,1]
Output: 1
Explanation: The product of all values in the array is 144, and signFunc(144) = 1
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [1,5,0,2,-3]
Output: 0
Explanation: The product of all values in the array is 0, and signFunc(0) = 0
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: nums = [-1,1,-1,1,-1]
Output: -1
Explanation: The product of all values in the array is -1, and signFunc(-1) = -1
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="solution-54"><a class="header" href="#solution-54">Solution</a></h2>
<h3 id="code-rust-24"><a class="header" href="#code-rust-24">Code (Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn array_sign(nums: Vec&lt;i32&gt;) -&gt; i32 {
        nums
            .into_iter()
            .map( |a| if a &lt; 0 { -1 } else if a &gt; 0 { 1 } else { 0 } )
            .reduce(|a, b| a * b)
            .unwrap()
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1929-concatenation-of-array"><a class="header" href="#1929-concatenation-of-array">1929. Concatenation of Array</a></h1>
<h2 id="description-of-the-problem-40"><a class="header" href="#description-of-the-problem-40">Description of the Problem</a></h2>
<p>Given an integer array <code>nums</code> of length <code>n</code>, you want to create an array <code>ans</code> of length <code>2n</code> where <code>ans[i] == nums[i]</code> and <code>ans[i + n] == nums[i]</code> for <code>0 &lt;= i &lt; n</code> (<strong>0-indexed</strong>).</p>
<p>Specifically, <code>ans</code> is the concatenation of two <code>nums</code> arrays.</p>
<p>Return the array <code>ans</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h2 id="solution-55"><a class="header" href="#solution-55">Solution</a></h2>
<h3 id="coderust-6"><a class="header" href="#coderust-6">Code(Rust)</a></h3>
<pre><code class="language-Rust">impl Solution {
    pub fn get_concatenation(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        let mut res = nums.clone();
        for n in nums{
            res.push(n);
        }
        return res;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2331-evaluate-boolean-binary-tree"><a class="header" href="#2331-evaluate-boolean-binary-tree">2331. Evaluate Boolean Binary Tree</a></h1>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>You are given the <code>root</code> of a <strong>full binary tree</strong> with the following properties:</p>
<ul>
<li><strong>Leaf nodes</strong> have either the value <code>0</code> or <code>1</code>, where <code>0</code> represents <code>False</code> and <code>1</code> represents <code>True</code>.</li>
<li>Non-leaf nodes have either the value <code>2</code> or <code>3</code>, where <code>2</code> represents the boolean <code>OR</code> and <code>3</code> represents the boolean <code>AND</code>.</li>
</ul>
<p>The <strong>evaluation</strong> of a node is as follows:</p>
<ul>
<li>If the node is a leaf node, the evaluation is the <strong>value</strong> of the node, i.e. <code>True</code> or <code>False</code>.</li>
<li>Otherwise, <strong>evaluate</strong> the node's two children and <strong>apply</strong> the boolean operation of its value with the children's evaluations.</li>
</ul>
<p>Return the boolean result of <strong>evaluating</strong> the <code>root</code> <em>node</em>.</p>
<p>A <strong>full binary tree</strong> is a binary tree where each node has either <code>0</code> or <code>2</code> children.</p>
<p>A <strong>leaf node</strong> is a node that has zero children.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root = [2,1,3,null,null,0,1]
Output: true
Explanation: The above diagram illustrates the evaluation process.
The AND node evaluates to False AND True = False.
The OR node evaluates to True OR False = True.
The root node evaluates to True, so we return true.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: root = [0]
Output: false
Explanation: The root node is a leaf node and it evaluates to false, so we return false.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 3</code></li>
<li>Every node has either <code>0</code> or <code>2</code> children.</li>
<li>Leaf nodes have a value of <code>0</code> or <code>1</code>.</li>
<li>Non-leaf nodes have a value of <code>2</code> or <code>3</code>.</li>
</ul>
<h2 id="solution-56"><a class="header" href="#solution-56">Solution</a></h2>
<h3 id="code-rust-25"><a class="header" href="#code-rust-25">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
//   pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -&gt; Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
    pub fn evaluate_tree(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; bool {
        if root.is_some() {
            let root = root.unwrap();
            let root = root.borrow();
            let v = root.val;
             return match v{
                0 =&gt;  false,

                1 =&gt; true,

                2 =&gt; Solution::evaluate_tree( root.left.clone() ) ||    
                    Solution::evaluate_tree( root.right.clone() ),

                3 =&gt; Solution::evaluate_tree( root.left.clone() ) &amp;&amp;    
                    Solution::evaluate_tree( root.right.clone() ),
                
                _ =&gt; false,
            }
        }
        else{
            return false;
        }
    }
}
</code></pre>
<h3 id="code-c-8"><a class="header" href="#code-c-8">Code (C++)</a></h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool evaluateTree(TreeNode* root) {
        int val = root-&gt;val;
        if ( val == 0 )
            return false;
        else if (val == 1)
            return true;
        else if (val == 2)
            return evaluateTree(root-&gt;left) || evaluateTree(root-&gt;right);
        else
            return evaluateTree(root-&gt;left) &amp;&amp; evaluateTree(root-&gt;right);
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-remove-nth-node-from-end-of-list"><a class="header" href="#19-remove-nth-node-from-end-of-list">19. Remove Nth Node From End of List</a></h1>
<h2 id="description-of-the-problem-41"><a class="header" href="#description-of-the-problem-41">Description of the Problem</a></h2>
<p>Given the <code>head</code> of a linked list, remove the nth node from the end of the list and return its <code>head</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [1], n = 1
Output: []
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: head = [1,2], n = 1
Output: [1]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is sz.</li>
<li>1 &lt;= sz &lt;= 30</li>
<li>0 &lt;= Node.val &lt;= 100</li>
<li>1 &lt;= n &lt;= sz</li>
</ul>
<p>Follow up: Could you do this in one pass?</p>
<h2 id="solution-does-not-fullfill-the-follow-up-question"><a class="header" href="#solution-does-not-fullfill-the-follow-up-question">Solution (Does not fullfill the follow-up question)</a></h2>
<h3 id="code-java-17"><a class="header" href="#code-java-17">Code (Java)</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode currentNode = head;
        int len = 0;
        while(currentNode != null){
            len++;
            currentNode = currentNode.next;
        }

        ListNode sentinelHead = new ListNode(-1, head);
        currentNode = sentinelHead;
        while( len - n &gt; 0 ){
            n++;
            currentNode = currentNode.next;
        }
        currentNode.next = currentNode.next.next;
        return sentinelHead.next;
    }
}
</code></pre>
<h3 id="code-rust-26"><a class="header" href="#code-rust-26">Code (Rust)</a></h3>
<pre><code class="language-Rust">// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//   pub val: i32,
//   pub next: Option&lt;Box&lt;ListNode&gt;&gt;
// }
// 
// impl ListNode {
//   #[inline]
//   fn new(val: i32) -&gt; Self {
//     ListNode {
//       next: None,
//       val
//     }
//   }
// }
impl Solution {
    pub fn remove_nth_from_end(head: Option&lt;Box&lt;ListNode&gt;&gt;, n: i32) 
        -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {

        let mut n = n;
        // Reverse The List
        let mut curr = head;
        let mut prev = None;
        while let Some(mut node) = curr.take() {
            curr = node.next;
            node.next = prev;
            prev = Some(node);
        }

        // Reverse again and delete
        curr = prev;
        prev = None;
        while let Some(mut node) = curr.take() {
            n-=1;
            if (n != 0){
                curr = node.next;
                node.next = prev;
                prev = Some(node);
            }else{
                curr = node.next;
            }
        }

        return prev;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="46-permutations"><a class="header" href="#46-permutations">46. Permutations</a></h1>
<h2 id="description-of-the-problem-42"><a class="header" href="#description-of-the-problem-42">Description of the Problem</a></h2>
<p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in any <strong>order</strong>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [0,1]
Output: [[0,1],[1,0]]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: nums = [1]
Output: [[1]]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>10 &lt;= nums[i] &lt;= 10</code>
All the integers of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
<h2 id="solution-57"><a class="header" href="#solution-57">Solution</a></h2>
<h3 id="code-3"><a class="header" href="#code-3">Code</a></h3>
<pre><code class="language-Rust">impl Solution {
    fn helper_permute(nums: &amp;[i32])-&gt;Vec&lt;Vec&lt;i32&gt;&gt;{
        if nums.len() == 0{
            return vec![vec![]];
        }

        if nums.len() == 1{
            return vec![nums.to_vec()];
        }

        let mut return_vec = vec![];

        for i in 0..nums.len(){
            let chosen = nums[i];
            let permutations = Solution::helper_permute(&amp;[&amp;nums[0..i], &amp;nums[i+1..]].concat());

            for perm in permutations {
                let permutations = [ &amp;[chosen] , &amp;perm[..] ].concat();
                return_vec.push(permutations);
            }
        }

        return return_vec;
    }

    pub fn permute(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        return Solution::helper_permute(&amp;nums);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="207-course-schedule"><a class="header" href="#207-course-schedule">207. Course Schedule</a></h1>
<h2 id="description-of-problem-14"><a class="header" href="#description-of-problem-14">Description of Problem</a></h2>
<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you must take course <code>b_i</code> first if you want to take course <code>a_i</code>.</p>
<p>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.
Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= a_i, b_i &lt; numCourses</code></li>
<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>
</ul>
<h2 id="solution-58"><a class="header" href="#solution-58">Solution</a></h2>
<h3 id="code-rust-27"><a class="header" href="#code-rust-27">Code (Rust)</a></h3>
<pre><code class="language-Rust">use std::collections::HashMap;

impl Solution {
    pub fn can_finish(num_courses: i32, prerequisites: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; bool {
        let num_courses = num_courses as usize;

        let mut adj_list : Vec&lt;Vec&lt;usize&gt;&gt; = vec![ vec![] ; num_courses ];
        let mut is_gray : Vec&lt;bool&gt; = vec![false; num_courses];
        let mut is_black : Vec&lt;bool&gt; = vec![false; num_courses];

        for p in prerequisites.into_iter(){
            let (c1, c2) = (p[1] as usize, p[0] as usize);
            adj_list[c1].push(c2);
        }

        let mut has_loop = false;

        for vertex in (0..num_courses) {
            if !is_black[vertex] &amp;&amp; !is_gray[vertex] &amp;&amp; !has_loop {
                has_loop = Self::visit(vertex, &amp;adj_list, &amp;mut is_gray, &amp;mut is_black);
            }
        }

        !has_loop
    }

    fn visit(
        vertex : usize, 
        adj_list : &amp;Vec&lt;Vec&lt;usize&gt;&gt;,
        is_gray : &amp;mut Vec&lt;bool&gt;,
        is_black : &amp;mut Vec&lt;bool&gt;
    ) -&gt; bool {
            for &amp;v in adj_list[vertex].iter() {
                match (is_black[v], is_gray[v]){
                    (false, false) =&gt; {
                        is_gray[v] = true;
                        if Self::visit(v, adj_list, is_gray, is_black) == true {
                            return true;
                        }
                        is_gray[v] = false;
                    }
                    (false, true) =&gt; return true,
                    _ =&gt; {}
                }
            }
        is_black[vertex] = true;
        return false;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="210-course-schedule-ii"><a class="header" href="#210-course-schedule-ii">210. Course Schedule II</a></h1>
<h2 id="description-of-the-problem-43"><a class="header" href="#description-of-the-problem-43">Description of the Problem</a></h2>
<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array prerequisites where <code>prerequisites[i] = [a_i, b_i]</code> indicates that you <strong>must</strong> take course bi first if you want to take course <code>a_i</code>.</p>
<ul>
<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>
<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: numCourses = 1, prerequisites = []
Output: [0]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= a_i, b_i &lt; numCourses</code></li>
<li><code>a_i != b_i</code></li>
<li>All the pairs <code>[a_i, b_i]</code> are <strong>distinct</strong>.</li>
</ul>
<h2 id="solution-59"><a class="header" href="#solution-59">Solution</a></h2>
<h3 id="code-4"><a class="header" href="#code-4">Code</a></h3>
<pre><code class="language-Rust">use std::collections::{HashMap, VecDeque};

impl Solution {
    pub fn find_order(num_courses: i32, prerequisites: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;i32&gt; {
        let num_courses = num_courses as usize;

        let mut adj_list : Vec&lt;Vec&lt;usize&gt;&gt; = vec![ vec![] ; num_courses ];
        let mut is_gray : Vec&lt;bool&gt; = vec![false; num_courses];
        let mut is_black : Vec&lt;bool&gt; = vec![false; num_courses];
        let mut order : VecDeque&lt;i32&gt; = VecDeque::new();

        for p in prerequisites.into_iter(){
            let (c1, c2) = (p[1] as usize, p[0] as usize);
            adj_list[c1].push(c2);
        }

        let mut has_loop = false;

        for vertex in (0..num_courses) {
            if !is_black[vertex] &amp;&amp; !is_gray[vertex] &amp;&amp; !has_loop {
                has_loop = Self::visit(vertex, &amp;adj_list, &amp;mut is_gray, &amp;mut is_black, &amp;mut order);
            }
        }

        if !has_loop { order.into_iter().collect::&lt;Vec&lt;i32&gt;&gt;() } else { vec![] }
    }

    fn visit(
        vertex : usize, 
        adj_list : &amp;Vec&lt;Vec&lt;usize&gt;&gt;,
        is_gray : &amp;mut Vec&lt;bool&gt;,
        is_black : &amp;mut Vec&lt;bool&gt;,
        order : &amp;mut VecDeque&lt;i32&gt;
    ) -&gt; bool {
        for &amp;v in adj_list[vertex].iter() {
            match (is_black[v], is_gray[v]){
                (false, false) =&gt; {
                    is_gray[v] = true;
                    if Self::visit(v, adj_list, is_gray, is_black, order) == true {
                        return true;
                    }
                    is_gray[v] = false;
                }
                (false, true) =&gt; return true,
                _ =&gt; {}
            }
        }
        is_black[vertex] = true;
        order.push_front(vertex as i32);
        return false;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="237-delete-node-in-a-linked-list"><a class="header" href="#237-delete-node-in-a-linked-list">237. Delete Node in a Linked List</a></h1>
<h2 id="description-of-the-problem-44"><a class="header" href="#description-of-the-problem-44">Description of the Problem</a></h2>
<p>There is a singly-linked list head and we want to delete a node <code>node</code> in it.</p>
<p>You are given the <code>node</code> to be deleted node. You will not be given access to the first node of <code>head</code>.</p>
<p>All the values of the linked list are unique, and it is guaranteed that the given node <code>node</code> is not the last node in the linked list.</p>
<p>Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:</p>
<ul>
<li>The value of the given node should not exist in the linked list.</li>
<li>The number of nodes in the linked list should decrease by one.</li>
<li>All the values before <code>node</code> should be in the same order.</li>
<li>All the values after <code>node</code> should be in the same order.</li>
</ul>
<p><strong>Custom testing:</strong></p>
<ul>
<li>For the input, you should provide the entire linked list <code>head</code> and the node to be given <code>node</code>. <code>node</code> should not be the last node of the list and should be an actual node in the list.</li>
<li>We will build the linked list and pass the node to your function.</li>
<li>The output will be the entire list after calling your function.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code>
The value of each node in the list is <strong>unique</strong>.
The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node.</li>
</ul>
<h2 id="solution-60"><a class="header" href="#solution-60">Solution</a></h2>
<h3 id="code-5"><a class="header" href="#code-5">Code</a></h3>
<pre><code class="language-Java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {

    public void deleteNode(ListNode node) {
        if(node != null){
            node.val = node.next.val;
            node.next = node.next.next;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="68-text-justification"><a class="header" href="#68-text-justification">68. Text Justification</a></h1>
<h2 id="description-of-the-problem-45"><a class="header" href="#description-of-the-problem-45">Description of the Problem</a></h2>
<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>' '</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>
<p><strong>Note:</strong></p>
<ul>
<li>A word is defined as a character sequence consisting of non-space characters only.</li>
<li>Each word's length is guaranteed to be greater than <code>0</code> and not exceed <code>maxWidth</code>.</li>
<li>The input array <code>words</code> contains at least one word.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16
Output:
[
   &quot;This    is    an&quot;,
   &quot;example  of text&quot;,
   &quot;justification.  &quot;
]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16
Output:
[
  &quot;What   must   be&quot;,
  &quot;acknowledgment  &quot;,
  &quot;shall be        &quot;
]
Explanation: Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified because it contains only one word.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code>Input: words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;], maxWidth = 20
Output:
[
  &quot;Science  is  what we&quot;,
  &quot;understand      well&quot;,
  &quot;enough to explain to&quot;,
  &quot;a  computer.  Art is&quot;,
  &quot;everything  else  we&quot;,
  &quot;do                  &quot;
]
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 300</code></li>
<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
<li><code>words[i]</code> consists of only English letters and symbols.</li>
<li><code>1 &lt;= maxWidth &lt;= 100</code></li>
<li><code>words[i].length &lt;= maxWidth</code></li>
</ul>
<h2 id="solution-61"><a class="header" href="#solution-61">Solution</a></h2>
<h3 id="code-rust-28"><a class="header" href="#code-rust-28">Code (Rust)</a></h3>
<pre><code class="language-Rust">struct Bucket{
    min_width : usize,
    words : Vec&lt;String&gt;,
}

impl Bucket {

    pub fn distribute_spaces(a : usize, b : usize) -&gt; Vec&lt;usize&gt; {
        let mut return_vec = Vec::new();
        for _ in 0..b{
            return_vec.push(0);
        }
        for i in 0..a{
            let v = return_vec.get_mut(i % b);
            let v = v.unwrap();
            *(v)+=1;
        }
        return return_vec;
    }

    pub fn new() -&gt; Bucket{
        return Bucket{
            min_width : 0,
            words : Vec::new(),
        };
    }

    // put string into bucket
    pub fn push(&amp;mut self, word : String){
        // the bucket does not contain any string
        if self.words.len() == 0 {
            self.min_width += word.len();
        }
        else {
            self.min_width += 1 + word.len();
        }
        self.words.push(word);
    }

    pub fn get_min_width(&amp;self) -&gt; usize {
        return self.min_width;
    }
    
    pub fn into_string_line(self, max_width : usize, is_last_line : bool) -&gt; String{
        let len_words = self.words.len();
        let total_spaces : usize = max_width - self.words.iter().map(|s| s.len()).sum::&lt;usize&gt;();
        let mut return_string = String::new();


        if len_words == 1{
            return_string.push_str(&amp;self.words[0]);
            return_string.push_str(&amp;&quot; &quot;.repeat(total_spaces));
            return return_string;
        }

        let mut spaces = Bucket::distribute_spaces(total_spaces,len_words - 1).into_iter();

        for (i, word) in self.words.iter().enumerate(){
            // push word into return_string
            return_string.push_str(word);

            // push spaces into return_string
            match is_last_line{
                true =&gt; {
                    // case for the last word of a bucket
                    if i == len_words - 1{
                        return_string.push_str(&amp;&quot; &quot;.repeat(max_width - return_string.len()));
                    }
                    else{
                        return_string.push_str(&quot; &quot;);
                    }
                }
                false =&gt; {
                    // case for the last word of a bucket
                    if i != len_words - 1{
                        return_string.push_str( &amp;&quot; &quot;.repeat(spaces.next().unwrap()));
                    }
                }
            }
        }

        return return_string;
    }
}


impl Solution {
    pub fn full_justify(words: Vec&lt;String&gt;, max_width: i32) -&gt; Vec&lt;String&gt; {
        let mut buckets : Vec&lt;Bucket&gt; = Vec::new();

        let mut bucket = Bucket::new();
        for word in words.into_iter() {
            if bucket.get_min_width() == 0 {
                bucket.push(word);
            }
            else if word.len() + bucket.get_min_width() + 1 &lt;= max_width as usize {
                bucket.push(word);
            }
            else{
                buckets.push(bucket);
                bucket = Bucket::new();
                bucket.push(word);
            }
        }
        buckets.push(bucket); // put the last bucket into vector


        let mut return_vec : Vec&lt;String&gt; = Vec::new();

        let bucket_size = buckets.len();
        for (i, bucket) in buckets.into_iter().enumerate(){
            return_vec.push(bucket.into_string_line(max_width as usize, i==bucket_size - 1));
        }

        return return_vec;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="295-find-median-from-data-stream"><a class="header" href="#295-find-median-from-data-stream">295. Find Median from Data Stream</a></h1>
<h2 id="description-of-the-problem-46"><a class="header" href="#description-of-the-problem-46">Description of the Problem</a></h2>
<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>
<p>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.
For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.
Implement the MedianFinder class:</p>
<p><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.
<code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.
<code>double findMedian()</code> returns the median of all elements so far. Answers within \(10^{-5}\) of the actual answer will be accepted.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input
[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
</code></pre>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>-10^5 &lt;= num &lt;= 10^5</code></li>
<li>There will be at least one element in the data structure before calling findMedian.</li>
<li>At most <code>5 * 10^4</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li>
</ul>
<p><strong>Follow up:</strong></p>
<ul>
<li>If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>
<li>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>
</ul>
<h2 id="solution-62"><a class="header" href="#solution-62">Solution</a></h2>
<h3 id="code-java-18"><a class="header" href="#code-java-18">Code (Java)</a></h3>
<pre><code class="language-Java">class MedianFinder {

    private final PriorityQueue&lt;Integer&gt; leftMaxHeap;
    private final PriorityQueue&lt;Integer&gt; rightMinHeap;

    public MedianFinder() {
        leftMaxHeap = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());
        rightMinHeap = new PriorityQueue&lt;Integer&gt;();
    }
    
    public void addNum(int num) {
        Integer leftMax = leftMaxHeap.peek();
        if (leftMax != null &amp;&amp; num &lt;= leftMax){
            leftMaxHeap.add(num);
            if (leftMaxHeap.size() - rightMinHeap.size() &gt; 1 ){
                rightMinHeap.add(leftMaxHeap.poll());
            }
        }else {
            rightMinHeap.add(num);
            if (rightMinHeap.size() - leftMaxHeap.size() &gt; 1 ){
                leftMaxHeap.add(rightMinHeap.poll());
            }
        }
    }
    
    public double findMedian() {
        if ( (leftMaxHeap.size() + rightMinHeap.size())  % 2 == 0){
            return leftMaxHeap.peek() / 2.0 + rightMinHeap.peek() / 2.0;
        }else if (leftMaxHeap.size() &gt; rightMinHeap.size()){
            return leftMaxHeap.peek() * 1.0;
        }else{
            return rightMinHeap.peek() * 1.0;
        }
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
